{
  "count": 20,
  "start": 0,
  "total": 932,
  "books": [
    {
      "rating": {
        "max": 10,
        "numRaters": 20,
        "average": "5.1",
        "min": 0
      },
      "subtitle": "A Programmer's Guide",
      "author": [
        "J.F. DiMarzio"
      ],
      "pubdate": "2008-7-30",
      "tags": [
        {
          "count": 16,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 6,
          "name": "Mobile",
          "title": "Mobile"
        },
        {
          "count": 4,
          "name": "Google",
          "title": "Google"
        },
        {
          "count": 3,
          "name": "Phone",
          "title": "Phone"
        },
        {
          "count": 2,
          "name": "技术",
          "title": "技术"
        },
        {
          "count": 1,
          "name": "Android.A.Programmers.Guide",
          "title": "Android.A.Programmers.Guide"
        },
        {
          "count": 1,
          "name": "programming",
          "title": "programming"
        },
        {
          "count": 1,
          "name": "力的来源!",
          "title": "力的来源!"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\\/mpic\\/s4259006.jpg",
      "binding": "Paperback",
      "translator": [],
      "catalog": "",
      "pages": "400",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s4259006.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s4259006.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s4259006.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/3134548\\/",
      "id": "3134548",
      "publisher": "McGraw-Hill Osborne Media",
      "isbn10": "0071599886",
      "isbn13": "9780071599887",
      "title": "Android",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/3134548",
      "alt_title": "",
      "author_intro": "",
      "summary": "Master the Android mobile development platform  Build compelling Java-based mobile applications using the Android SDK and the Eclipse open-source software development platform. Android: A Programmer's Guide shows you, step-by-step, how to download and set up all of the necessary tools, build and tune dynamic Android programs, and debug your results. Discover how to provide web and chat functions, interact with the phone dialer and GPS devices, and access the latest Google services. You'll also learn how to create custom Content Providers and database-enable your applications using SQLite.  Install and configure Java, Eclipse, and Android plugin  Create Android projects from the Eclipse UI or command line  Integrate web content, images, galleries, and sounds  Deploy menus, progress bars, and auto-complete functions  Trigger actions using Android Intents, Filters, and Receivers  Implement GPS, Google Maps, Google Earth, and GTalk Build interactive SQLite databases, calendars, and notepads  Test applications using the Android Emulator and Debug Bridge",
      "price": "USD 39.99"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 154,
        "average": "8.2",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "范怀宇"
      ],
      "pubdate": "2012-8",
      "tags": [
        {
          "count": 340,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 105,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 53,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 41,
          "name": "android",
          "title": "android"
        },
        {
          "count": 32,
          "name": "互联网",
          "title": "互联网"
        },
        {
          "count": 24,
          "name": "范老师",
          "title": "范老师"
        },
        {
          "count": 21,
          "name": "大牛之作",
          "title": "大牛之作"
        },
        {
          "count": 20,
          "name": "计算机技术",
          "title": "计算机技术"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s11184539.jpg",
      "binding": "",
      "translator": [],
      "catalog": "前言\n致谢\n第1章　Android的系统架构\\/1\n1.1　Android系统架构概况\\/2\n1.1.1　应用层\\/4\n1.1.2　框架层\\/5\n1.1.3　运行时\\/5\n1.1.4　核心类库\\/7\n1.1.5　硬件抽象层和Linux内核\\/7\n1.2　Android的核心功能模块\\/8\n1.2.1　界面框架\\/8\n1.2.2　数据存储\\/9\n1.2.3　网络通信\\/10\n1.2.4　地理信息\\/11\n1.2.5　图形和多媒体处理\\/11\n1.2.6　外部设备\\/12\n1.2.7　特色功能模块\\/13\n1.3　Android的架构特征和设计思想\\/13\n1.3.1　平台开放性\\/14\n1.3.2　基于组件的应用设计\\/14\n1.3.3　基于网络服务的平台\\/15\n1.4　小结\\/15\n第2章　Android源代码的下载和编译\\/16\n2.1　Android源代码的获取和编译\\/17\n2.1.1　环境搭建\\/18\n2.1.2　源代码获取\\/18\n2.1.3　源代码的编译\\/21\n2.2　Android源代码结构\\/22\n2.2.1　框架层源代码目录frameworks\\/22\n2.2.2　应用层源代码目录packages\\/24\n2.2.3　其他源代码目录\\/24\n2.3　Android源代码的阅读和编辑\\/25\n2.3.1　用Eclipse阅读源代码\\/25\n2.3.2　反馈Bug\\/26\n2.3.3　提交修改\\/27\n2.4　小结\\/27\n第3章　Android组件模型解析\\/28\n3.1　基于Mashup的应用设计\\/29\n3.1.1　Android中的Mashup\\/29\n3.1.2　基于Mashup的Android应用模型\\/30\n3.1.3　基于Mashup的应用架构特征\\/32\n3.2　界面组件Activity解析\\/34\n3.2.1　界面组件的功能和特征\\/34\n3.2.2　界面组件的开发\\/35\n3.2.3　界面组件的数据结构\\/39\n3.3　服务组件Service解析\\/40\n3.3.1　服务组件的功能和特征\\/41\n3.3.2　服务组件的开发和使用\\/43\n3.3.3　服务组件的进程间通信模型\\/45\n3.4　触发器组件Broadcast Receiver解析\\/49\n3.4.1　触发器组件的功能和特征\\/49\n3.4.2　触发器组件的使用\\/50\n3.4.3　广播事件的发送\\/52\n3.5　数据源组件Content Provider解析\\/52\n3.5.1　数据源组件的定位和操作\\/53\n3.5.2　数据源组件的开发\\/55\n3.5.3　数据源组件的实现细节\\/57\n3.6　应用配置文件解析\\/59\n3.6.1　权限配置\\/61\n3.6.2　环境配置\\/63\n3.6.3　应用和组件配置\\/65\n3.7　小结\\/66\n第4章　Android的Intent机制\\/67\n4.1　Intent对象的作用和构成\\/68\n4.1.1　Intent对象的作用\\/69\n4.1.2　Intent对象的构成\\/70\n4.1.3　Intent对象解析\\/75\n4.1.4　Intent Filter对象\\/76\n4.2　意图匹配\\/78\n4.2.1　意图匹配的算法流程\\/79\n4.2.2　匹配组件的选择\\/84\n4.2.3　意图匹配的优化\\/85\n4.3　意图机制的应用\\/86\n4.3.1　意图机制在界面组件中的应用\\/86\n4.3.2　意图机制在服务组件中的应用\\/88\n4.3.3　意图机制在触发器组件中的应用\\/89\n4.4　小结\\/90\n第5章　组件生命周期解析\\/91\n5.1　应用进程模型\\/92\n5.1.1　应用、组件和进程\\/92\n5.1.2　组件的应用进程配置\\/94\n5.2　应用进程托管\\/96\n5.2.1　为什么需要进程托管\\/97\n5.2.2　进程优先级\\/97\n5.2.3　进程回收算法\\/100\n5.2.4　进程的强行终止\\/103\n5.2.5　掌控进程的优先级\\/105\n5.3　组件的生命周期模型\\/106\n5.3.1　界面组件的生命周期\\/107\n5.3.2　服务组件的生命周期\\/115\n5.3.3　触发器组件的生命周期\\/119\n5.3.4　数据源组件的生命周期\\/120\n5.3.5　应用环境的生命周期\\/120\n5.4　任务和界面组件栈\\/120\n5.4.1　界面组件的运行模式\\/122\n5.4.2　组件的任务黏度\\/126\n5.4.3　实际应用中的任务控制\\/127\n5.5　小结\\/128\n第6章　组件间的数据传输\\/129\n6.1　利用Intent对象进行数据传输\\/130\n6.1.1　利用Intent对象回传数据\\/131\n6.1.2　利用Intent对象传递数据的优缺点\\/133\n6.2　利用文件进行数据共享\\/134\n6.2.1　利用文件进行数据共享的实现\\/134\n6.2.2　利用文件进行数据共享的优缺点\\/135\n6.3　利用应用环境的全局数据共享\\/136\n6.3.1　利用应用环境对象共享数据的实现\\/137\n6.3.2　利用应用环境对象共享数据的优缺点\\/138\n6.4　利用组件共享数据\\/139\n6.4.1　利用数据源组件共享数据\\/139\n6.4.2　利用服务组件共享数据\\/140\n6.5　小结\\/140\n第7章　Android控件解析\\/141\n7.1　Android的控件框架\\/142\n7.1.1　Android控件构成\\/142\n7.1.2　Android交互事件传输\\/143\n7.1.3　Android控件属性\\/145\n7.1.4　控件的丈量和绘制\\/150\n7.2　Android的窗口机制\\/150\n7.2.1　窗口机制的基本原理\\/151\n7.2.2　界面组件和窗口\\/152\n7.2.3　对话框\\/154\n7.2.4　弹出窗口\\/156\n7.3　Android的基本控件介绍\\/158\n7.3.1　文本控件\\/159\n7.3.2　图像控件\\/163\n7.3.3　Surface控件\\/164\n7.3.4　Layout控件\\/164\n7.3.5　适配器控件\\/167\n7.3.6　选项卡控件\\/172\n7.3.7　浏览器控件\\/173\n7.4　自定义控件\\/175\n7.4.1　控件的定制\\/175\n7.4.2 　复合控件\\/180\n7.4.3　自绘控件\\/183\n7.5　Android界面新发展\\/188\n7.5.1　动作栏\\/188\n7.5.2　界面片段\\/191\n7.5.3　重新定制选项卡\\/197\n7.5.4　交互界面的适配\\/200\n7.6　小结\\/204\n第8章　应用资源\\/205\n8.1　Android应用资源体系\\/206\n8.1.1　Android的应用资源构成\\/206\n8.1.2　应用资源的适配\\/208\n8.1.3　应用资源的动态匹配\\/209\n8.2　应用资源的调用\\/213\n8.2.1　应用资源的编译和R类\\/213\n8.2.2　应用资源的管理\\/215\n8.2.3　使用应用资源\\/216\n8.3　应用资源的类型\\/217\n8.3.1　界面和样式\\/217\n8.3.2　字符串和常量\\/221\n8.3.3　图像、图形和动画\\/223\n8.3.4　其他资源文件\\/225\n8.4　小结\\/225\n第9章　数据存储\\/226\n9.1　Android的文件系统\\/227\n9.1.1　Android的目录结构\\/229\n9.1.2　Android的应用数据存储\\/229\n9.1.3　Android的文件操作\\/231\n9.2　使用设置文件\\/233\n9.2.1　设置文件的存储和使用\\/234\n9.2.2　设置界面组件\\/235\n9.3　使用数据库\\/238\n9.3.1　Android数据库实现\\/238\n9.3.2　Android数据库的使用\\/240\n9.4　存储在云端\\/243\n9.4.1　云端存储的架构\\/244\n9.4.2　云端存储的使用\\/245\n9.5　小结\\/247\n第10章　网络通信\\/248\n10.1　Web通信\\/249\n10.1.1　基于HTTP的网络连接\\/249\n10.1.2　联网方式的选择\\/252\n10.1.3　WiFi的管理\\/254\n10.2　蓝牙\\/256\n10.2.1　Android的蓝牙实现\\/256\n10.2.2　基于蓝牙的通信\\/257\n10.3　近场通信\\/259\n10.3.1　基于NFC的识别和通信\\/259\n10.3.2　基于NFC的点对点通信\\/263\n10.4　基于WiFi连接的P2P通信\\/263\n10.4.1　Android 4.0的P2P连接实现\\/264\n10.4.2　使用Socket进行数据传输\\/266\n10.5　小结\\/268\n第11章　地理信息服务\\/269\n11.1　Android的定位服务\\/270\n11.1.1　定位服务框架\\/270\n11.1.2　位置信息源\\/272\n11.1.3　定位选择\\/273\n11.1.4　定位实例\\/274\n11.2　Android的地址服务\\/277\n11.2.1　地址服务的框架\\/277\n11.2.2　使用地址服务\\/278\n11.3　Android的地图服务\\/279\n11.3.1　使用地图\\/279\n11.3.2　其他使用地图服务的方式\\/282\n11.4　小结\\/283\n第12章　多媒体处理\\/284\n12.1　Android的图像处理\\/285\n12.1.1　图像的表示\\/285\n12.1.2　图像的读取和输出\\/286\n12.1.3　图像的呈现\\/288\n12.1.4　图像的管理\\/290\n12.2　Android的音视频处理\\/291\n12.2.1　Android音视频的支持框架\\/291\n12.2.2　Android音视频的播放\\/292\n12.2.3　Android音视频的录制\\/294\n12.3　Android中相机的使用\\/296\n12.4　小结\\/300\n第13章　其他重要模块\\/301\n13.1　通话和短信\\/302\n13.1.1　Android的通话和短信框架\\/302\n13.1.2　通话的处理\\/303\n13.1.3　短信的发送和接收\\/305\n13.2　App Widget的使用和实现\\/308\n13.2.1　Android的App Widget框架\\/309\n13.2.2　App Widget的界面构造和Remote Views \\/311\n13.2.3　App Widget的事件处理和Pending Intent \\/313\n13.3　Android的应用内搜索\\/317\n13.3.1　Android应用内搜索实现框架\\/317\n13.3.2　为应用定制搜索功能\\/318\n13.3.3　全局搜索功能\\/322\n13.4　Android的全局通知机制\\/323\n13.4.1　全局通知的类型和实现\\/324\n13.4.2　Toast的使用\\/325\n13.4.3　状态栏通知\\/327\n13.5　Android联系人处理\\/331\n13.5.1　Android联系人数据存储框架\\/331\n13.5.2　Android联系人操作\\/332\n13.6　小结\\/334",
      "ebook_url": "http:\\/\\/read.douban.com\\/ebook\\/15171473\\/",
      "pages": "356",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s11184539.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s11184539.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s11184539.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/11530748\\/",
      "id": "11530748",
      "publisher": "机械工业出版社",
      "isbn10": "711139058X",
      "isbn13": "9787111390589",
      "title": "Android开发精要",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/11530748",
      "alt_title": "",
      "author_intro": "范怀宇，资深Android开发工程师，毕业于清华大学，从事移动开发多年，对Android系统有颇为深入的研究，开发经验十分丰富。曾就职于网易有道，负责完成了有道词典Android版、网易掌上邮Android版、网易八方Android版等项目的开发工作，现就职于豌豆实验室 ，负责豌豆荚2.0版本的设计和开发。\n作者微博：@duguguiyu（http:\\/\\/weibo.com\\/duguguiyu）\n个人站点：http:\\/\\/flyvenus.net",
      "summary": "《Android开发精要》如何才能写出贴近Android设计理念、能够更加高效和可靠运行的Android应用？通过Android的源代码去了解其底层实现细节是最重要的方法之一！然而，Android系统太过于庞大，源代码实现复杂，学习的技术门槛和时间成本都很高。有没有一种方法既能帮助开发者深入理解Android应用开发，又能不被底层大量的实现细节所羁绊，迅速掌握编写高质量Android应用所需的知识？《Android开发精要》针对这个问题给出了完美的答案！它从Android繁杂的源代码中抽取出了Android开发的“精华”和“要点”，剥离了大量琐碎的底层实现细节，进行了高度概括和总结，不仅能帮助开发者迅速从宏观上理解整个Android系统的设计理念，而且能帮助开发者迅速从微观上掌握核心知识点的原理，从而编写出高质量的Android应用。\n《Android开发精要》共13章，在逻辑上分为4个部分。第一部分（1-2章）：第1章系统介绍了Android的系统架构、核心模块和设计思想，旨在让读者真正理解它的设计理念；第2章讲解了Android源代码的获取、编译、阅读和编辑的方法。第二部分（3-6章）：第3章深入阐述了Android组件机制的设计理念和重要特征，并详细介绍了4大组件的方法和原理；第4章讲解了Intent对象和Android的意图机制，阐明了Android是如何将来自不同应用、不同进程的组件整合在一起的；第5章解析了Android中各个组件的生命周期，包括组件的进程模型和线程模型；第6章从开发的角度详细阐述了组件间数据传递的解决方案，以及它们的优缺点和适用场景。第三部分（7-8章）：第7章深入讲解了Android的控件框架，结合实际项目对重要控件的实现和使用逐一进行了分析，还包含Android 4.0界面开发的实践“精华”；第8章分析了Android的资源体系，剖析了Android底层对资源的处理。第4部分（9-13章）：第9章讲解了Android的数据存储结构，以及不同数据存储模式的使用要点；第10章分析了Android的各种网络连接方式，涵盖NFC和基于Wifi的P2P连接等内容；第11章讲解了Android的定位服务、地址解析服务、地图服务的框架实现；第12章仔细分析了Android各种多媒体功能的实现机制；第13章对Android中比较有特色的一些模块的实现细节进行了分析。\n海报：",
      "ebook_price": "30.00",
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 241,
        "average": "6.4",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "姚尚朗",
        "靳岩"
      ],
      "pubdate": "2009 年6月",
      "tags": [
        {
          "count": 235,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 55,
          "name": "Google",
          "title": "Google"
        },
        {
          "count": 50,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 39,
          "name": "应用开发",
          "title": "应用开发"
        },
        {
          "count": 33,
          "name": "程序设计",
          "title": "程序设计"
        },
        {
          "count": 23,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 21,
          "name": "java",
          "title": "java"
        },
        {
          "count": 21,
          "name": "programming",
          "title": "programming"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\\/mpic\\/s3817805.jpg",
      "binding": "16开",
      "translator": [],
      "catalog": "第1章　掀起你的盖头来——初识android　1\n1.1　认识android　1\n1.2　android的背景　2\n1.2.1　android的历史　2\n1.2.2　android的发展　2\n1.3　我的android我做主　2\n1.3.1　开发基于android平台的应用　3\n1.3.2　参加android开发者大赛　3\n1.3.3　个人英雄主义再现——得到更多人的认可和尊重　3\n1.3.4　获得应有的收益——android market　3\n1.4　真实体验——android模拟器　4\n1.4.1　模拟器概述　4\n1.4.2　模拟器和真机的区别　4\n1.4.3　模拟器使用注意事项　4\n1.5　更上一层楼——加入android开发社区　5\n1.6　本章小结　6\n第2章　工欲善其事　必先利其器——搭建android开发环境　7\n2.1　开发android应用前的准备　7\n2.1.1　android开发系统要求　7\n2.1.2　android软件开发包　7\n2.1.3　其他注意事项　8\n2.2　windows开发环境搭建　8\n2.2.1　jdk、eclipse、android sdk软件安装　8\n2.2.2　sdk的家在哪里——设定android sdk home　14\n2.2.3　真的准备好了吗——开发环境验证　14\n2.2.4　创建android 虚拟设备(avd)　15\n2.3　linux一族——ubuntu开发环境搭建　17\n2.3.1　java、eclipse和adt插件安装　17\n2.3.2　设定android sdk home　23\n2.4　mac os一族——苹果开发环境搭建　24\n2.5　本章小结　24\n第3章　清点可用资本——android sdk介绍　25\n3.1　android sdk 基础　25\n3.2　深入探寻android sdk的密码　25\n3.2.1　android sdk目录结构　25\n3.2.2　android.jar及内部结构　27\n3.2.3　sdk文档及阅读技巧　27\n3.2.4　先来热热身——android sdk例子解析　28\n3.2.5　sdk提供的工具介绍　31\n3.3　android典型包分析　33\n3.3.1　开发的基石——android api核心开发包介绍　33\n3.3.2　拓展开发外延——android可选api介绍　34\n3.4　本章小结　34\n第4章　赚钱的市场——android market及应用发布　35\n4.1　google market产生背景与目的　35\n4.2　体验“选货”的乐趣——在g1上体验market的使用　35\n4.3　android开发活动及特色应用　37\n4.3.1　开发应用的领域　37\n4.3.2　android market特色应用一览　38\n4.4　你也可以做东家——申请market账号　43\n4.4.1　卖东西要先入伙——准备工作　43\n4.4.2　入伙过程——申请　44\n4.5　开张了——在market上发布应用　45\n4.5.1　发布时可能遇到的错误　45\n4.5.2　卖东西也要签名——生成签名文件　46\n4.5.3　打包、签名、发布应用　48\n4.6　本章小结　51\n第5章　千里之行 始于足下——第一个应用helloworld　52\n5.1　helloworld应用分析　52\n5.1.1　新建一个android工程　52\n5.1.2　填写工程的信息　52\n5.1.3　编程实现　53\n5.1.4　运行项目　54\n5.2　调试项目　54\n5.2.1　设置断点　54\n5.2.2　debug 项目　55\n5.2.3　断点调试　55\n5.3　本章小结　56\n第6章　磨刀不误砍柴工——android应用程序结构介绍　57\n6.1　android体系结构介绍　57\n6.1.1　应用程序(application)　57\n6.1.2　应用程序框架(application framework)　58\n6.1.3　库(libraries)和运行环境(runtime)　58\n6.2　android 应用程序组成　59\n6.2.1　activity介绍　59\n6.2.2　broadcast intent receiver介绍　60\n6.2.3　service介绍　61\n6.2.4　content provider介绍　61\n6.3　android应用工程文件组成　61\n6.4　本章小结　62\n第7章　良好的学习开端——android基本组件介绍　63\n7.1　第一印象很重要——界面ui元素介绍　63\n7.1.1　视图组件(view)　63\n7.1.2　视图容器组件(viewgroup)　63\n7.1.3　布局组件(layout)　64\n7.1.4　布局参数(layoutparams)　64\n7.2　我的美丽我做主——android中应用界面布局　64\n7.2.1　实例操作演示　65\n7.2.2　实例编程实现　66\n7.3　不积跬步 无以至千里——常用widget组件介绍　75\n7.3.1　创建widget组件实例　75\n7.3.2　按钮(button)介绍与应用　76\n7.3.3　文本框(textview)介绍与应用　77\n7.3.4　编辑框(edittext)介绍与应用　79\n7.3.5　多项选择(checkbox)介绍与应用　81\n7.3.6　单项选择(radiogroup )介绍与应用　83\n7.3.7　下拉列表(spinner )介绍与应用　85\n7.3.8　自动完成文本(autocompletetextview )　87\n7.3.9　日期选择器(datepicker)介绍与应用　89\n7.3.10　时间选择器(timepicker)介绍与应用　90\n7.3.11　滚动视图(scrollview)介绍与应用　91\n7.3.12　进度条(progressbar)介绍与应用　92\n7.3.13　拖动条(seekbar)介绍与应用　93\n7.3.14　评分组件(ratingbar)介绍与应用　94\n7.3.15　图片视图(imageview)介绍与应用　95\n7.3.16　图片按钮(imagebutton)介绍与应用　96\n7.3.17　切换图片(imageswitcher&gallery)　96\n7.3.18　网格视图(gridview)介绍与应用　99\n7.3.19　标签(tab)介绍与应用　101\n7.4　友好的菜单——menu介绍与实例　102\n7.4.1　实例操作演示..　103\n7.4.2　实例编程实现　103\n7.5　android应用的灵魂——intent和activity介绍与实例　106\n7.5.1　实例操作演示　106\n7.5.2　实例编程实现　106\n7.6　用好列表，做好程序——列表(listview)介绍与实例　111\n7.6.1　实例程序演示　111\n7.6.2　实例编程实现　112\n7.7　友好地互动交流——对话框(dialog)介绍与实例　119\n7.8　温馨的提醒——toast和notification应用　127\n7.8.1　实例操作演示　128\n7.8.2　实例编程实现　129\n7.9　本章小结　135\n第8章　移动信息仓库——android的数据存储操作　136\n8.1　android数据存储概述　136\n8.2　轻轻地我保护——sharedpreferences存储　136\n8.3　谁的文件，谁主宰——文件存储　140\n8.4　打造自己的数据库存储——sqlite存储方式　141\n8.4.1　android中对数据库操作　141\n8.4.2　完整地操作数据库——日记本实例　147\n8.5　我的数据你来用——contentprovider介绍　155\n8.5.1　初识contentprovider　155\n8.5.2　使用contentprovider读取系统数据　156\n8.5.3　使用contentprovider操作数据日记本实例　159\n8.6　再学一招——网络存储　171\n8.7　本章小结　173\n第9章　我来“广播”你的“意图”——intent和broadcast面对面　174\n9.1　android应用程序的核心——intent　174\n9.1.1　intent基础　174\n9.1.2　用intent启动一个新的activity　174\n9.1.3　intent 详细讲解　177\n9.1.4　android解析intent实现　179\n9.2　用广播告诉你——利用intent来广播(broadcast)事件　180\n9.2.1　实现android中的广播事件　180\n9.2.2　broadcast receiver介绍　181\n9.3　应用实例详解　181\n9.3.1　程序操作演示　182\n9.3.2　实例编程实现　182\n9.4　本章小结　186\n第10章　一切为用户服务——service应用实例　187\n10.1　认识service　187\n10.2　使用service　188\n10.3　service的生命周期　194\n10.4　实例学习service　194\n10.4.1　精彩实例一——定时提醒　194\n10.4.2　精彩实例二——音乐播放器　198\n10.5　本章小结　201\n第11章　循序渐进——开发android应用的基本步骤　202\n11.1　兵马未动 粮草先行——应用规划及架构设计　202\n11.2　应用开发步骤　202\n11.2.1　界面设计始终是第一位——实现ui　203\n11.2.2　必备的动力源泉——数据操作和存储　203\n11.2.3　华丽转身——实现多页面跳转　203\n11.2.4　始终为用户做好服务——增加service　203\n11.2.5　细节决定成败——完善应用细节　203\n11.3　成功就在眼前——应用测试和发布　204\n11.3.1 只欠东风——应用测试　204\n11.3.2　可以赚钱了——发布到android market　204\n11.4　本章小结　204\n第12章　android综合案例一——rss阅读器实例　205\n12.1　rss介绍　205\n12.1.1　rss基础　205\n12.1.2　rss的历史　205\n12.1.3　rss语法介绍　206\n12.2　sax介绍　207\n12.2.1　sax基础　207\n12.2.2　使用sax的作用　207\n12.2.3　怎样使用sax　207\n12.3　rss阅读器设计　209\n12.3.1　rss阅读器功能设计　209\n12.3.2　rss阅读器ui和交互流程设计　209\n12.4　rss阅读器的实现　210\n12.4.1　程序实体解析　210\n12.4.2　实现一个自己的contenthandler　214\n12.4.3　activity的实现　217\n12.5　本章小结　220\n第13章　android综合案例二——基于google map开发个人移动地图　221\n13.1　项目ui规划　221\n13.2　数据存储实现　222\n13.2.1　设计数据库及表结构　222\n13.2.2　设计sharepreference 存储　223\n13.3　项目实现流程　223\n13.3.1　创建项目工程　223\n13.3.2　项目各功能及界面实现　224\n13.3.3　实现数据存取　247\n13.3.4　实现service　252\n13.3.5　应用流程整体实现　254\n13.3.6　后续开发完善　255\n13.4　项目程序演示　255\n13.5　项目程序签名、打包和发布　257\n13.6　本章小结　259\n第14章　android综合案例三——基于android的豆瓣网(web 2.0)移动客户端开发　260\n14.1　关于豆瓣网和豆瓣网api　260\n14.1.1　豆瓣网介绍　260\n14.1.2　豆瓣网api介绍　261\n14.1.3　豆瓣网api认证　261\n14.1.4　豆瓣网api快速入门　264\n14.1.5　豆瓣网api java库介绍　265\n14.2　豆瓣网(web 2.0)客户端设计　268\n14.2.1　客户端功能规划设计　268\n14.2.2　ui和交互流程设计　268\n14.2.3　数据存储设计　270\n14.3　豆瓣网(web 2.0)客户端实现　270\n14.3.1　申请api key　270\n14.3.2　activity实现　271\n14.4　本章小结　282\n第15章　android综合案例四——在线音乐播放器　283\n15.1　关于yobo和yobo api　283\n15.1.1　yobo简介　284\n15.1.2　yobo功能特点　284\n15.1.3　yobo api介绍　284\n15.2　在线播放器架构设计　285\n15.2.1　在线播放器功能规划设计　285\n15.2.2　在线播放器ui设计　285\n15.2.3　在线播放器数据存储设计　286\n15.3　在线播放器的编程实现　286\n15.3.1　申请api key　286\n15.3.2　基础功能实现　287\n15.3.3　实现activity　290\n15.3.4　实现service　306\n15.3.5　后续开发展望　310\n15.4　在线音乐播放器应用演示　310\n15.5　在线音乐播放器应用打包、签名和发布　311\n15.6　本章小结　311\n第16章　android综合案例五——手机信息查看助手　312\n16.1　手机信息查看助手功能规划和可行性分析　312\n16.1.1　手机信息查看助手功能规划　312\n16.1.2　手机信息查看助手可行性分析　312\n16.2　手机信息查看助手功能实现　313\n16.2.1　手机信息查看助手主界面　313\n16.2.2　查看系统信息实现　316\n16.2.3　查看硬件信息　320\n16.2.4　查看软件信息　324\n16.2.5　获取运行时信息　326\n16.2.6　文件浏览器　328\n16.2.7　项目的细节完善　331\n16.3　手机信息查看助手功能展望　332\n16.4　项目的打包、签名和发布　332\n16.5　本章小结　333\n第17章　芝麻开门——android底层开发和移植概述　334\n17.1　android原始码下载　334\n17.2　实机测试　335\n17.2.1　neo freerunner 介绍　335\n17.2.2　烧录androidfs.jffs2　336\n17.3　android移植技术概论　337\n17.3.1　android底层技术的重要性　337\n17.3.2　android移植项目介绍　338\n17.3.3　android的技术优点　340",
      "pages": "400",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s3817805.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s3817805.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s3817805.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/3770255\\/",
      "id": "3770255",
      "publisher": "人民邮电出版社",
      "isbn10": "7115209308",
      "isbn13": "9787115209306",
      "title": "Google Android开发入门与实战",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/3770255",
      "alt_title": "",
      "author_intro": "本书由国内Android知名专业开发团队eoeMobile团队倾心撰写。eoeMoblie团队国内最早一批专注于Android开发的专业团队，目前团队已经在Google Market上有超过5款的作品，而且取得了可喜的下载量。国内著名网站豆瓣网的Android客户端(eoeDouban)也是由此团队制作。关于此团队的更多信息请访问:http:\\/\\/www.eoemobile.com.关于图书的进展，可以访问http:\\/\\/www.eoeandroid.com 社区\n作者简介：\n靳岩:\n网名：海阳|haiyangjy\nblog: http:\\/\\/www.haiyangjy.com\n姚尚朗:\n网名:iceskysl\nblog: http:\\/\\/iceskysl.1sters.com\n欢迎大家就书或者Android的问题和我们进行直接的交流。\n社区支持:http:\\/\\/www.eoeandroid.com\\/",
      "summary": "本书内容上覆盖了用Android开发的大部分场景，从Android基础介绍、环境搭建、SDK介绍、Market使用，到应用剖析、组件介绍、实例演示等方面。从技术实现上，讲解了5个Android平台下的完整综合实例及源代码分析，分别是RSS阅读器、基于Google Map的个人GPS、豆瓣网（Web 2.0）客户端、在线音乐播放器、手机信息助手。\n本书注重对实际动手能力的指导，在遵循技术研发知识体系的严密性同时，在容易产生错误、不易理解的环节配以了详实的开发情景截图，并将重要的知识点和经验技巧以“小实验”、“小知识”的活泼形式呈现给读者。在程序实例的讲解方面，将实例安插在Android开发的精髓知识章节，这为初学者学习与实践结合提供了很好的指导。.\n本书配套有300多分钟的全程开发视频光盘，指导读者快速、无障碍地学通Android实战开发技术。..\n本书适合具备一定软件开发经验，想快速进入Android开发领域的程序员；具备一些手机开发经验的开发者和Android开发爱好者学习用书；也适合作为相关培训学校的Android培训教材。\n特点：\n* 第一本国内开发团队原创的Android图书\n* 完全基于Android最新的SDK1.5\n* 著名台湾技术专家高焕堂、Google Android工程师何峰、InfoQ站长霍泰稳鼎力推荐！\n* 全书除了大量小型案例之外还包含了5个Android平台下的完整商业实例及源码分析，分别是RSS阅读器、基于GoogleMap的个人GPS、豆瓣客户端、在线音乐播放器、手机信息助手\n* 随书附赠的光盘中包含389分钟的详细教学视频以及Android开发必备开发资源，部分教学视频免费下载地址：http:\\/\\/www.eoeandroid.com\\/viewthread.php?tid=328\n* 读者对于此书内容的疑问可以访问http:\\/\\/www.eoeandroid.com社区，作者团队将会及时解答",
      "price": "55.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 93,
        "average": "8.0",
        "min": 0
      },
      "subtitle": "卷I",
      "author": [
        "邓凡平"
      ],
      "pubdate": "2011-9-5",
      "tags": [
        {
          "count": 275,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 90,
          "name": "Andriod源码分析",
          "title": "Andriod源码分析"
        },
        {
          "count": 34,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 32,
          "name": "android",
          "title": "android"
        },
        {
          "count": 30,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 20,
          "name": "计算机科学",
          "title": "计算机科学"
        },
        {
          "count": 17,
          "name": "移动互联网",
          "title": "移动互联网"
        },
        {
          "count": 10,
          "name": "程序设计",
          "title": "程序设计"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s11171603.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "第1章　阅读前的准备工作 \\/ 1\n1.1　系统架构 \\/ 2\n1.1.1　Android系统架构 \\/ 2\n1.1.2　本书的架构 \\/ 3\n1.2　搭建开发环境 \\/ 4\n1.2.1　下载源码 \\/ 4\n1.2.2　编译源码 \\/ 6\n1.3　工具介绍 \\/ 8\n1.3.1　Source Insight介绍 \\/ 8\n1.3.3　Busybox的使用 \\/ 11\n1.4　本章小结 \\/ 12\n第2章　深入理解JNI \\/ 13\n2.1　JNI概述 \\/ 14\n2.2　学习JNI的实例：MediaScanner \\/ 15\n2.3　Java层的MediaScanner分析 \\/ 16\n2.3.1　加载JNI库 \\/ 16\n2.3.2　Java的native函数和总结 \\/ 17\n2.4　JNI层MediaScanner的分析 \\/ 17\n2.4.1　注册JNI函数 \\/ 18\n2.4.2　数据类型转换 \\/ 22\n2.4.3　JNIEnv介绍 \\/ 24\n2.4.4　通过JNIEnv操作jobject \\/ 25\n2.4.5　jstring介绍 \\/ 27\n2.4.6　JNI类型签名介绍 \\/ 28\n2.4.7　垃圾回收 \\/ 29\n2.4.8　JNI中的异常处理 \\/ 32\n2.5　本章小结 \\/ 32\n第3章　深入理解init \\/ 33\n3.1　概述 \\/ 34\n3.2　init分析 \\/ 34\n3.2.1　解析配置文件 \\/ 38\n3.2.2　解析service \\/ 42\n3.2.3　init控制service \\/ 48\n3.2.4　属性服务 \\/ 52\n3.3　本章小结 \\/ 60\n第4章　深入理解zygote \\/ 61\n4.1　概述 \\/ 62\n4.2　zygote分析 \\/ 62\n4.2.1　AppRuntime分析 \\/ 63\n4.2.2　Welcome to Java World \\/ 68\n4.2.3　关于zygote的总结 \\/ 74\n4.3　SystemServer分析 \\/ 74\n4.3.1　SystemServer的诞生 \\/ 74\n4.3.2　SystemServer的重要使命 \\/ 77\n4.3.3　关于 SystemServer的总结 \\/ 83\n4.4　zygote的分裂  \\/ 84\n4.4.1　ActivityManagerService发送请求 \\/ 84\n4.4.2　有求必应之响应请求 \\/ 86\n4.4.3　 关于zygote分裂的总结 \\/ 88\n4.5　拓展思考 \\/ 88\n4.5.1　虚拟机heapsize的限制 \\/ 88\n4.5.2　开机速度优化 \\/ 89\n4.5.3　Watchdog分析 \\/ 90\n4.6　本章小结 \\/ 93\n第5章　深入理解常见类 \\/ 95\n5.1　概述 \\/ 96\n5.2　以“三板斧”揭秘RefBase、sp和wp \\/ 96\n5.2.1　第一板斧——初识影子对象 \\/ 96\n5.2.2　第二板斧——由弱生强 \\/ 103\n5.2.3　第三板斧——破解生死魔咒 \\/ 106\n5.2.4　轻量级的引用计数控制类LightRefBase \\/ 108\n5.2.5　题外话—三板斧的来历 \\/ 109\n5.3　Thread类及常用同步类分析 \\/ 109\n5.3.1　一个变量引发的思考 \\/ 109\n5.3.2　常用同步类 \\/ 114\n5.4　Looper和Handler类分析 \\/ 121\n5.4.1　Looper类分析 \\/ 122\n5.4.2　Handler分析 \\/ 124\n5.4.3　Looper和Handler的同步关系 \\/ 127\n5.4.4　HandlerThread介绍 \\/ 129\n5.5　本章小结 \\/ 129\n第6章　深入理解Binder \\/ 130\n6.1　概述 \\/ 131\n6.2　庖丁解MediaServer \\/ 132\n6.2.1　MediaServer的入口函数 \\/ 132\n6.2.2　独一无二的ProcessState \\/ 133\n6.2.3　时空穿越魔术—defaultServiceManager \\/ 134\n6.2.4　注册MediaPlayerService \\/ 142\n6.2.5　秋风扫落叶—StartThread Pool和join Thread Pool分析 \\/ 149\n6.2.6　你彻底明白了吗 \\/ 152\n6.3　服务总管ServiceManager \\/ 152\n6.3.1　ServiceManager的原理 \\/ 152\n6.3.2　服务的注册 \\/ 155\n6.3.3　ServiceManager存在的意义 \\/ 158\n6.4　MediaPlayerService和它的Client \\/ 158\n6.4.1　查询ServiceManager \\/ 158\n6.4.2　子承父业 \\/ 159\n6.5　拓展思考 \\/ 162\n6.5.1　Binder和线程的关系 \\/ 162\n6.5.2　有人情味的讣告 \\/ 163\n6.5.3　匿名Service \\/ 165\n6.6　学以致用 \\/ 166\n6.6.1　纯Native的Service \\/ 166\n6.6.2　扶得起的“阿斗”（aidl） \\/ 169\n6.7　本章小结 \\/ 172\n第7章　深入理解Audio系统 \\/ 173\n7.1　概述 \\/ 174\n7.2　AudioTrack的破解 \\/ 174\n7.2.1　用例介绍 \\/ 174\n7.2.2　AudioTrack（Java空间）分析 \\/ 179\n7.2.3　AudioTrack（Native空间）分析 \\/ 188\n7.2.4　关于AudioTrack的总结 \\/ 200\n7.3　AudioFlinger的破解 \\/ 200\n7.3.1　AudioFlinger的诞生 \\/ 200\n7.3.2　通过流程分析AudioFlinger \\/ 204\n7.3.3　audio_track_cblk_t分析 \\/ 230\n7.3.4　关于AudioFlinger的总结 \\/ 234\n7.4　AudioPolicyService的破解 \\/ 234\n7.4.1　AudioPolicyService的创建 \\/ 235\n7.4.2　重回AudioTrack \\/ 245\n7.4.3　声音路由切换实例分析 \\/ 251\n7.4.4　关于AudioPolicy的总结 \\/ 262\n7.5　拓展思考 \\/ 262\n7.5.1　DuplicatingThread破解 \\/ 262\n7.5.2　题外话 \\/ 270\n7.6　本章小结 \\/ 272\n第8章　深入理解Surface系统 \\/ 273\n8.1　概述 \\/ 275\n8.2　一个Activity的显示 \\/ 275\n8.2.1　Activity的创建 \\/ 275\n8.2.2　Activity的UI绘制 \\/ 294\n8.2.3　关于Activity的总结 \\/ 296\n8.3　初识Surface \\/ 297\n8.3.1　和Surface有关的流程总结 \\/ 297\n8.3.2　Surface之乾坤大挪移 \\/ 298\n8.3.3　乾坤大挪移的JNI层分析 \\/ 303\n8.3.4　Surface和画图 \\/ 307\n8.3.5　初识Surface小结 \\/ 309\n8.4　深入分析Surface \\/ 310\n8.4.1　与Surface相关的基础知识介绍 \\/ 310\n8.4.2　SurfaceComposerClient分析 \\/ 315\n8.4.3　SurfaceControl分析 \\/ 320\n8.4.4　writeToParcel和Surface对象的创建 \\/ 331\n8.4.5　lockCanvas和unlockCanvasAndPost分析 \\/ 335\n8.4.6　GraphicBuffer介绍 \\/ 344\n8.4.7　深入分析Surface的总结 \\/ 353\n8.5　SurfaceFlinger分析 \\/ 353\n8.5.1　SurfaceFlinger的诞生 \\/ 354\n8.5.2　SF工作线程分析 \\/ 359\n8.5.3　Transaction分析 \\/ 368\n8.5.4　关于SurfaceFlinger的总结 \\/ 376\n8.6　拓展思考 \\/ 377\n8.6.1　Surface系统的CB对象分析 \\/ 377\n8.6.2　ViewRoot的你问我答 \\/ 384\n8.6.3　LayerBuffer分析 \\/ 385\n8.7　本章小结 \\/ 394\n第9章　深入理解Vold和Rild \\/ 395\n9.1　概述 \\/ 396\n9.2　Vold的原理与机制分析 \\/ 396\n9.2.1　Netlink和Uevent介绍 \\/ 397\n9.2.2　初识Vold \\/ 399\n9.2.3　NetlinkManager模块分析 \\/ 400\n9.2.4　VolumeManager模块分析 \\/ 408\n9.2.5　CommandListener模块分析 \\/ 414\n9.2.6　Vold实例分析 \\/ 417\n9.2.7　关于Vold的总结 \\/ 428\n9.3　Rild的原理与机制分析 \\/ 428\n9.3.1　初识Rild \\/ 430\n9.3.2　RIL_startEventLoop分析 \\/ 432\n9.3.3　RIL_Init分析 \\/ 437\n9.3.4　RIL_register分析 \\/ 444\n9.3.5　关于Rild main函数的总结 \\/ 447\n9.3.6　Rild实例分析 \\/ 447\n9.3.7　关于Rild的总结 \\/ 459\n9.4　拓展思考 \\/ 459\n9.4.1　嵌入式系统的存储知识介绍 \\/ 459\n9.4.2　Rild和Phone的改进探讨 \\/ 462\n9.5　本章小结 \\/ 463\n第10章　深入理解MediaScanner \\/ 464\n10.1　概述 \\/ 465\n10.2　android.process.media分析 \\/ 465\n10.2.1　MSR模块分析 \\/ 466\n10.2.2　MSS模块分析 \\/ 467\n10.2.3　android.process.media媒体扫描工作的流程总结 \\/ 471\n10.3　MediaScanner分析 \\/ 472\n10.3.1　Java层分析 \\/ 472\n10.3.2　JNI层分析 \\/ 476\n10.3.3　PVMediaScanner分析 \\/ 479\n10.3.4　关于MediaScanner的总结 \\/ 485\n10.4　拓展思考 \\/ 486\n10.4.1　MediaScannerConnection介绍 \\/ 486\n10.4.2　我问你答 \\/ 487\n10.5　本章小结 \\/ 488",
      "pages": "488",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s11171603.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s11171603.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s11171603.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/6802440\\/",
      "id": "6802440",
      "publisher": "机械工业出版社",
      "isbn10": "7111357620",
      "isbn13": "9787111357629",
      "title": "深入理解Android",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/6802440",
      "alt_title": "",
      "author_intro": "邓凡平，资深Android开发工程师，热衷于Android源代码的研究，对Android的架构设计和实现原理有非常深刻的认识和理解，应用开发经验也十分丰富。目前就职于国内一家领先的Android企业，负责Framework的开发和维护。乐于分享，活跃于CSDN等专业社区，撰写的Android Framework源码的系列文章深受读者欢迎。此外，他对Linux内核、C\\/C++\\/Python相关的技术，以及高性能网络服务器和多核并行开发等也有一定的研究。",
      "summary": "《深入理解Android：卷I》是一本以情景方式对Android的源代码进行深入分析的书。内容广泛，以对Framework层的分析为主，兼顾Native层和Application层；分析深入，每一部分源代码的分析都力求透彻；针对性强，注重实际应用开发需求，书中所涵盖的知识点都是Android应用开发者和系统开发者需要重点掌握的。\n全书共10章，第1章介绍了阅读本书所需要做的准备工作，主要包括对Android系统架构和源码阅读方法的介绍；第2章通过对Android系统中的MediaScanner进行分析，详细讲解了Android中十分重要的JNI技术；第3章分析了init进程，揭示了通过解析init.rc来启动Zygote以及属性服务的工作原理；第4章分析了Zygote、SystemServer等进程的工作机制，同时还讨论了Android的启动速度、虚拟机HeapSize的大小调整、Watchdog工作原理等问题；第5章讲解了Android系统中常用的类，包括sp、wp、RefBase、Thread等类，同步类，以及Java中的Handler类和Looper类，掌握这些类的知识后方能在后续的代码分析中做到游刃有余；第6章以MediaServer为切入点，对Android中极为重要的Binder进行了较为全面的分析，深刻揭示了其本质。第7章对Audio系统进行了深入的分析，尤其是AudioTrack、AudioFlinger和AudioPolicyService等的工作原理。第8章深入讲解了Surface系统的实现原理，分析了Surface与Activity之间以及Surface与SurfaceFlinger之间的关系、SurfaceFlinger的工作原理、Surface系统中的帧数据传输以及LayerBuffer的工作流程。第9章对Vold和Rild的原理和机制进行了深入的分析，同时还探讨了Phone设计优化的问题；第10章分析了多媒体系统中MediaScanner的工作原理。\n本书适合有一定基础的Android应用开发工程师和系统工程师阅读。通过对本书的学习，大家将能更深刻地理解Android系统，从而自如应对实际开发中遇到的难题。",
      "series": {
        "id": "28292",
        "title": "深入理解Android"
      },
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 231,
        "average": "6.6",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "杨丰盛"
      ],
      "pubdate": "2010-1",
      "tags": [
        {
          "count": 173,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 60,
          "name": "Android开发",
          "title": "Android开发"
        },
        {
          "count": 32,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 27,
          "name": "软件开发",
          "title": "软件开发"
        },
        {
          "count": 26,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 26,
          "name": "Android应用开发揭秘",
          "title": "Android应用开发揭秘"
        },
        {
          "count": 11,
          "name": "移动开发",
          "title": "移动开发"
        },
        {
          "count": 10,
          "name": "Google",
          "title": "Google"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s4143787.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "前言\n第一部分 准备篇\n第1章 android开发简介\n1.1 android基本概念\n1.1.1 android简介\n1.1.2 android的系统构架\n1.1.3 android应用程序框架\n1.2 oms介绍\n1.2.1 ophone介绍\n1.2.2 widget介绍\n1.3 小结\n第2章 android开发环境搭建\n2.1 android开发准备工作\n2.2 开发包及其工具的安装和\n配置\n2.2.1 安装jdk和配置java开发\n环境\n2.2.2 eclipse的安装与汉化\n2.2.3 sdk和adt的安装和\n.配置\n2.3 创建第一个android项目——heuoandroid\n2.3.1 创建helloandroid项目\n2.3.2 运行helloandroid及模拟器的使用\n2.3.3 调试helloandroid\n2.4 小结\n第二部分 基础篇\n第3章 android程序设计基础\n3.1 android程序框架\n3.1.1 android项目目录结构\n3.1.2 android应用解析\n3.2 android的生命周期\n3.3 android程序u设计\n3.4 小结\n第4章 用户界面开发\n4.1 用户界面开发详解\n4.1.1 用户界面简介\n4.1.2 事件处理\n4.2 常用控件应用\n4.2.1 文本框(textiew)\n4.2.2 列表(listview)\n4.2.3 提示(t0ast)\n4.2.4 编辑框(edittext)\n4.2.5 单项选择(radiogroup、radiobutton\n4.2.6 多项选择(checkbox)\n4.2.7 下拉列表(spinner)\n4.2.8 自动提示(autocomplete.textⅵew)\n4.2.9 日期和时间(datepicker、timepicker)\n4.2.10 按钮(button)\n4.2.1l 菜单(menu)\n4.2.12 对话框(dialog)\n4.2.13 图片视图(imageview)\n4.2.14 带图标的按钮(imagebutton)\n4.2.15 拖动效果(gallery)\n4.2.16 切换图片(hmgeswilcher)\n4.2.17 网格视图(gridview)\n4.2.18 卷轴视图(scrollview)\n4.2.19 进度条(progressbar)\n4.2.20 拖动条(seekbar)\n4.2.21 状态栏提示(notification、notificationmanager)\n4.2.22 对话框中的进度条(progressdialog)\n4.3 界面布局\n4.3.1 垂直线性布局\n4.3.2 水平线性布局\n4.3.3.相对布局(relativelayout)\n4.3.4 表单布局(tablelayout)\n4.3.5 切换卡(tabwidget)\n4,4 小结\n第5章 android游戏开发\n5.1 android游戏开发框架\n5.1.1 view类开发框架\n5.1.2 surfaceview类开发框架\n5.2 graphics类开发\n5.5.1 paint和color类介绍\n5.2.2 canvas类介绍\n5.2.3 几何图形绘制\n5.2.4 字符串绘制\n5.2.5 图像绘制\n5.2.6 图像旋转\n5.2.7 图像缩放\n5.2.8 图像像素操作\n5.2.9 shader类介绍\n5.2.10 双缓冲技术\n5.2.11 全屏显示\n5.2.12 获得屏幕属性\n5.3 动画实现\n5.3.1 tween动画\n5.3.2 frame动画\n5.3.3 gif动画播放\n5.4 小结\n第6章 android数据存储\n6.1 android数据存储初探\n6.2 数据存储之shared preferences\n6.3 数据存储之files\n6.4 数据存储之network\n6.5 android数据库编程\n6.5.1 sqlite简介\n6.5.2 sqlite编程详解\n6.5.3 sqliteopenhelper应用\n6.6 数据共享(contentproviders)\n6.7 小结\n第7 章多媒体开发\n7.1 多媒体开发详解\n7.1.1 open core\n7.1.2 mediaplayer\n7.1.3 mediarecorder\n7.2 播放音乐\n7.3 播放视频\n7.4 录制歌曲\n7.5 相机设置\n7.6 闹钟设置\n7.7 铃声设置\n7.8 小结\n第8章 网络与通信\n8.1 网络通信基础\n8.1.1 无线网络技术\n8.1.2 android网络基础\n8.2 http通信\n8.2.1 httpurlconnection接口\n8.2.2 httpclient接口\n8.2.3 实时更新\n8.3 socket通信\n8.3.1 socket基础\n8.3.2 socket应用(简易聊天室)\n8.4 网络通信的中文乱码问题\n8.5 webkit应用\n8.5.1 webkjt概述\n8.5.2 webview浏览网页\n8.5.3 webview与javascript\n8.6 wtfi介绍\n8.7 蓝牙\n8.8 小结\n第9章 android特色开发\n9.1 传感器\n9.2 语音识别\n9.3 googlemap\n9.3.1 googlemap概述\n9.3.2 准备工作\n9.3.3 googlemapapi的使用\n9.3.4 定位系统\n9.4 桌面组件\n9.4.1 快捷方式\n9.4.2 实时文件夹\n9.4.3 widget开发\n9.5 账户管理\n9.6 小结\n第三部分 实例篇\n第10章 android应用开发\n实例\n10.1 情境模式\n10.2 文件管理器\n10.3 通讯录\n10.4 音乐播放器\n10.5 天气预报\n10.6 个人地图\n10.7 widget日历\n10.8 小结\n第11 章android游戏开发实例\n11.1 手机游戏开发简介\n11.2 游戏框架设计\n11.3 地图设计\n11.4 主角设计\n11.5 图层管理器\n11.6 游戏音效\n11.7 游戏存档\n11.8 小结\n第四部分 高级篇\n第12章 androidopengl开发\n基础\n12.1 opengl简介\n12.2 多边形\n12.3 颜色\n12.4 旋转\n12.5 3d 空间\n12.6 纹理映射\n12.7 光照和事件\n12.8 混合\n12.9 小结\n第13章 androidopengl综合\n应用\n13.1 移动图像\n13.2.3d 世界\n13.3 飘动的旗帜\n13.4 显示列表\n13.5 雾\n13.6 粒子系统\n13.7 蒙版\n13.8 变形\n13.9 小结\n第14章 游戏引擎实现\n14.1 游戏引擎介绍\n14.1.1 什么是引擎\n14.1.2 引擎的进化\n14.1.3 常见的游戏引擎\n14.1.4 android游戏引擎\n14.2 游戏引擎结构\n14.2.1 游戏引擎原理\n14.2.2 游戏引擎定位\n14.2.3 游戏引擎框架\n14.3 游戏引擎设计\n14.3.1 游戏引擎结构和功能\n设计\n14.3.2 游戏引擎设计注意事项\n14.4 游戏引擎实现\n14.4.1 activity类实现\n14.4.2 流程控制和线程\n14.4.3 游戏对象与对象管理\n14.4.4 图形引擎\n14.4.5 物理引擎\n14.4.6 事件模块\n14.4.7 工具模块\n14.4.8 脚本引擎、音效模块、网络\n模块\n14.5 小结\n第15章 优化技术\n15.1 优化的基本知识\n15.1.1 如何书写出优秀代码\n15.1.2 编程规范\n15.2 程序性能测试\n15.2.1 计算性能测试\n15.2.2 内存消耗测试\n15.3 初级优化\n15.4 高级优化\n15.5 android高效开发\n15.6 androidui优化\n15.7 其他优化\n15.7.1 zipalign\n15.7.2 图片优化\n15.8 小结\n第五部分 扩展篇\n第16章 android ndk开发\n16.1 androidndk简介\n16.2 安装和配置ndk开发环境\n16.2.1 系统和软件需求\n16.2.2 ndk开发环境搭建\n16.2.3 编译第一个ndk程序\n16.3 androidndk开发\n16.3.1 jni接口设计\n16.3.2 使用c\\c++实现本地\n方法\n16.3.3 android.mk实现\n16.3.4 application.mk实现\n16.3.5 编译c\\c++代码\n16.4 androidndk中使用0pengl\n16.5小结\n第17章 android脚本环境\n17.1 android脚本环境简介\n17.2 android脚本环境安装\n17.3如何编写android脚本程序\n17.4小结",
      "ebook_url": "http:\\/\\/read.douban.com\\/ebook\\/15091353\\/",
      "pages": "515",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s4143787.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s4143787.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s4143787.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/4200822\\/",
      "id": "4200822",
      "publisher": "机械工业出版社",
      "isbn10": "7111291956",
      "isbn13": "9787111291954",
      "title": "Android应用开发揭秘",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/4200822",
      "alt_title": "",
      "author_intro": "Android应用开发先驱，对Android有深入研究，实战经验极其丰富。精通Java、C、C++等语言，专注于移动通信软件开发，在机顶盒软件开发和MTK平台软件开发方面有非常深厚的积累。2007年获得中国软件行业协会游戏软件分会(CGIA)认证及国际游戏开发教育联合会国际认证。曾经领导和参与《三国群英传说》、《大航海传奇》、《美少女养成计划》等经典游戏的开发。",
      "summary": "内容简介：\n阿国内第一本基于Android 2.0的经典著作，5大专业社区联袂推荐，权威性毋庸置疑！\n本书内容全面，不仅详细讲解了Android框架、Android组件、用户界面开发、游戏开发、数据存储、多媒体开发和网络开发等基础知识，而且还深入阐述了传感器、语音识别、桌面组件开发、Android游戏引擎设计、Android应用优化、OpenGL等高级知识，最重要的是还全面介绍了如何利用原生的C\\/C++（NDK）和Python、Lua等脚本语言（Android Scripting Environment）来开发Android应用；本书实战性强，书中的每个知识点都有配精心设计的示例，尤为值得一提的是，它还以迭代的方式重现了各种常用的Android应用和经典Android游戏的开发全过程，既可以以它们为范例进行实战演练，又可以将它们直接应用到实际开发中去。\nWindows操作系统的诞生成就了微软的霸主地位，也造就了PC时代的繁荣。然而，以Android和iPhone手机为代表的智能移动设备的发明却敲响了PC时代的丧钟！移动互联网时代（3G时代）已经来临，谁会成为这些移动设备上的主宰？毫无疑问，它就是Android——PC时代的Windows！\n移动互联网还是一个新生的婴儿，各种移动设备上的操作系统群雄争霸！与Symbian、iPhone OS、Windows Mobile相比，Android有着天生的优势——完全开放和免费，对广大开发者和手机厂商而言，这是何等的诱人！此外，在Google和以其为首的Android手机联盟的大力支持和推广下，Android不仅得到了全球开发者社区的关注，而且一大批世界一流的手机厂商都已经或准备采用Android。\n拥抱Android开发，拥抱移动开发的未来！\n如果你在思考下面的问题，也许本书就是你想要的：\n·Android开发与传统的J2ME开发有何相似与不同？\n·如何通过Shared Preferences、Files、Network和SQLite等方式高效实现Android数据的存储？又如何通过Content Providers轻松地实现Android数据的共享？\n·如何使用Open Core、MediaPlayer、MediaRecorder方便快速地开发出包含音频和视频等流媒体的丰富多媒体应用？\n·如何利用Android 2.0中新增的蓝牙特性开发包含蓝牙功能的应用？又如何使用蓝牙API来完善应用的网络功能？\n·如何解决Android网络通信中的乱码问题？\n·在Android中如何使用语音服务和 Google Map API？Android如何访问摄像头、传感器等硬件的API？\n·如何进行Widget开发？如何用各种Android组件来打造漂亮的UI界面？\n·Android如何解析XML数据？又如何提高解析速度和减少对内存、CPU资源的消耗？\n·如何使用OpenGL ES在Android平台上开发出绚丽的3D应用？在Android平台上如何更好地设计和实现游戏引擎？\n·如何对Android应用进行优化？如何进行程序性能测试？如何实现UI、zipalign和图片优化？\n·如何通过NDK利用C、C++以及通过ASE利用Python等脚本语言开发Android应用？",
      "ebook_price": "44.16",
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 122,
        "average": "7.8",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "王世江"
      ],
      "pubdate": "2009-11",
      "tags": [
        {
          "count": 191,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 50,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 41,
          "name": "入门",
          "title": "入门"
        },
        {
          "count": 24,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 24,
          "name": "Google",
          "title": "Google"
        },
        {
          "count": 17,
          "name": "开发入门指南",
          "title": "开发入门指南"
        },
        {
          "count": 11,
          "name": "软件开发",
          "title": "软件开发"
        },
        {
          "count": 8,
          "name": "计算机科学",
          "title": "计算机科学"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s6089507.jpg",
      "binding": "",
      "translator": [],
      "catalog": "第1篇　入门篇\n第1章　初探Android\n1.1　Android是什么\n1.2　Android简史\n1.3　从创意开始\n1.4　参考资料\n第2章　安装Android开发工具\n2.1　系统需求\n2.1.1　操作系统\n2.1.2　必要开发工具\n2.1.3　其他开发环境工具（非必要安装）\n2.2　安装流程\n2.3　参考资料\n第3章　打开现有项目\n3.1　打开项目\n3.2　删除项目\n3.3　导入项目\n3.4　修复项目\n3.5　修改对应的目标版本\n3.6　参考资料\n第4章　操作Android模拟器（Emulator）\n4.1　设置环境参数\n4.2　设置Android模拟器\n4.3　使用命令行工具管理模拟器\n4.3.1　列出模拟器类型\n4.3.2　创建模拟器\n4.3.3　列出已创建的模拟器\n4.4　使用运行（Run）模式运行\n4.5　操作Android模拟器\n4.5.1　切换模拟器布局\n4.5.2　切换屏幕\n4.5.3　添加模拟器外观设置\n4.5.4　删除模拟器外观设置\n4.5.5　移除程序\n4.5.6　移除模拟器\n4.6　参考资料\n第5章　创建一个Android应用程序\n5.1　创建新项目\n5.2　程序项目架构\n5.2.1　src\\/：源代码（source）目录\n5.2.2　gen\\/：自动生成（Generate）目录\n5.2.3　res\\/：资源（Resource）目录\n5.2.4　Android功能列表\n5.2.5　“Android版本号\\/”参考函数目录\n5.3　参考资料\n第2篇　基础篇\n第6章　描述用户界面\n6.1　身高体重指数（BMI）计算\n6.2　表达用户界面\n6.3　参考资源\n第7章　设计用户界面\n7.1　视图（View）\n7.2　查阅文件\n7.2.1　线上文件\n7.2.2　脱机文件\n7.3　开始设计\n7.4　整合\n7.5　指定输入类型（InputType）\n7.6　视觉化的界面开发工具\n7.7　参考资料\n第8章　访问标识符号\n8.1　android:id属性\n8.2　XML说明文件与R.java资源文件\n8.3　将字符串抽离XML\n8.4　新增XML文件\n8.5　参考资料\n第9章　解读程序流程\n9.1　基础程序逻辑结构\n9.2　参考函数库\n9.3　参考资料\n第10章　完成BMI程序\n10.1　完整的程序\n10.2　程序解读\n第3篇　提高篇\n第11章　重构程序\n11.1　什么是重构\n11.2　重新查看BMI应用程序\n11.3　MVC模式\n11.4　重构BMI应用程序\n11.5　完整的Bmi.java程序 代码\n11.6　参考资料\n第12章　添加对话框（Dialog）\n12.1　设计对话框\n12.2　定义调用点\n12.3　实体对话框\n12.4　重构\n12.5　添加按钮\n12.6　Toast界面组件\n12.7　错误处理\n12.7.1　讲解\n12.7.2　提取字符串\n12.8　参考资料\n第13章　查看线上内容（Uri）\n13.1　打开网页\n13.1.1　讲解\n13.1.2　使用Uri查看Google地图\n13.2　再做好一点（重构）\n13.2.1　提取字符串\n13.2.2　避免出错\n13.3　参考资料\n第14章　添加菜单（Menu）\n14.1　菜单功能\n14.2　创建菜单\n14.2.1　装饰选项\n14.2.2　使用内置的菜单图标\n14.3　处理选项动作\n14.4　参考资料\n第15章　定义Android列表（Manifest）\n15.1　Android框架\n15.2　预设的Activity列表\n15.3　参考资料\n第16章　添加新活动（Activity）\n16.1　Activity的分类\n16.2　独立的Activity\n16.3　程序中创建新的Activity类文件\n16.4　在列表中添加Activity代码\n16.5　手动添加Activity标签\n16.6　修改页面标题文字\n16.7　原Activity类中添加startActivity函数\n第17章　传送数据到新意图（Intent）\n17.1　使用Intent传递数据\n17.2　使用Intent接收信息\n17.2.1　相关工作\n17.2.2　在Activity中解开信息\n17.2.3　讲解\n17.3　不通过Bundle交换信息\n第18章　信息提醒（Notification）\n18.1　状态栏提醒\n18.2　使用状态栏（Notification Bar）传递信息\n18.3　使用内置的状态图标\n18.4　参考资料\n第19章　日志与调试（Log）\n19.1　在程序中加上调试信息\n19.2　导入Log函数\n19.3　实际应用\n19.3.1　讲解\n19.3.2　其他的记录标记方式\n19.3.3　延伸使用\n19.4　在调试环境中查看除错信息\n19.4.1　启动模拟器\n19.4.2　切换到查错环境配置\n19.4.3　添加信息日志过滤器（Log Filter）\n19.5　模拟器上的调试设置\n19.6　管理日志\n19.7　在实机上调试\n19.8　参考资料\n第20章　活动的生命周期LifeCycle\n20.1　生命周期\n20.2　进程\n20.3　为什么要了解生命周期?\n20.4　Activity的状态\n20.4.1　Active（活动）\n20.4.2　Paused（暂停）\n20.4.3　Stopped（停止）\n20.4.4　Dead（已回收或未启动）\n20.5　系统内存不足时的行为\n20.6　观察Activity运行流程\n20.7　Activity运行流程\n20.7.1　一般启动\n20.7.2　调用另一个Activity\n20.7.3　返回原Activity\n20.7.4　退出结束\n20.7.5　回收后再启动\n20.8　参考资料\n第21章　优先级（Preference）\n21.1　使用优先级设置\n21.2　保存优先级设置\n21.3　参考资料\n第22章　开发不息\n22.1　回顾BMI应用程序\n22.2　BMI应用程序设计的缺陷\n22.3　展望未来\n第4篇　融会贯通篇\n第23章　显性设计\n23.1　做出容易使用的应用程序\n23.2　设计的减法\n23.3　规划应用程序的目标\n23.4　创建新项目\n23.4.1　XML说明文件\n23.4.2　文字字符串文件\n23.4.3　程序代码\n第24章　支持多国语言\n24.1　抽取文本文件\n24.2　让中文、英文多个语言界面并存\n24.3　切换语言\n24.3.1　设置中切换语系\n24.3.2　程序中切换语言\n24.4　参考资料\n第25章　针对特性配置（Orientation）\n25.1　配置资料夹的命名规则\n25.1.1　屏幕方向\n25.1.2　触控类型（Touc-hscreen type）\n25.1.3　文字输入方式（text input）\n25.1.4　浏览方式（navig-ation method）\n25.1.5　屏幕分辨率\n25.2　Android手机配置实例\n25.3　指定屏幕方向\n25.3.1　配置文件中指定屏幕方向\n25.3.2　程序中指定屏幕方向\n25.4　参考资料\n第26章　使用接口（Adapter）\n26.1　接口的概念\n26.2　数组接口（Array Adapter）与字符串数组\n26.3　数组字符串资源文件\n26.4　参考资料\n第27章　添加下拉菜单组件（Spinner）\n27.1　修改XML说明文件\n27.2　添加程序\n27.3　记录所选择的优先级\n27.4　参考资料\n第28章　签发应用程序密钥（Keytools）\n28.1　检查列表\n28.2　手动导出应用程序\n28.3　产生密钥\n28.4　签署密钥\n28.5　验证密钥\n28.6　安装到模拟器\n28.7　发布应用程序\n28.8　参考资料\n第29章　发布到Android Market\n29.1　Android Market的运作方式\n29.2　注册Android Market\n29.3　上传应用程序到Android Market\n29.4　查看成果——查看管理界面\n29.5　自行提供程序在线下载\n29.6　发布到第三方Android应用程序下载网站\n29.7　针对用户作设计\n29.8　参考资料\n第5篇　数据库应用\n第30章　添加列表活动（ListActivity）\n30.1　分析记事本程序\n30.2　创建新项目\n30.3　修改程序代码\n30.3.1　讲解\n30.3.2　自定义ListView组件\n30.3.3　自定义空列表显示内容\n30.4　参考内置范例\n30.5　参考资料\n第31章　使用数据库（SQLite）\n31.1　SQLite数据库简介\n31.2　查看模拟器目录\n31.3　手动创建“SQLite”数据库\n31.4　创建数据表（table）\n31.5　验证\n31.5.1　离开SQLite互动模式\n31.5.2　重新打开SQLite数据库\n31.6　让Android模拟器通过Proxy上网\n31.6.1　查询数据\n31.6.2　添加数据\n31.6.3　确认数据\n31.6.4　更新数据\n31.6.5　删除数据\n31.7　参考资料\n第32章　访问数据表（SQLite OpenHelper）\n32.1　SQLiteOpenHelper\n32.2　对NotesDbAdapter类加工\n32.3　使用NotesDb Adapter类\n32.3.1　讲解\n32.3.2　验证\n32.4　添加查询\n32.5　完整的程序\n32.6　参考资料\n第33章　添加增删改查操作（CRUD）\n33.1　检索（Retrieve）\n33.1.1　讲解\n33.1.2　验证\n33.2　添加（Create）\n33.2.1　讲解\n33.2.2　验证\n33.3　删除\n33.4　查询单条记录、修改\n33.5　参考资料\n第34章　添加相依的活动（Activity ForResult）\n34.1　定义XML说明文件\n34.2　添加编辑类\n34.3　将新Activity添加列表\n34.4　打开编辑页面\n34.5　完整的程序\n34.6　参考资料\n第35章　添加长按菜单（ContextMenu）\n35.1　添加长按菜单框架\n35.2　填入菜单内容\n35.3　后续改进\n35.4　参考资料\n第6篇　地图与定位应用\n第36章　申请Google地图服务（API Key）\n36.1　取得地点坐标\n36.2　取得Google地图开发密钥（API Key）\n36.2.1　调试用密钥（debug keystore）的位置\n36.2.2　取得MD5指纹信息\n36.3　参考资料\n第37章　使用地图（MapView）\n37.1　Google地图的组成元素\n37.2　创建新项目\n37.3　定义列表\n37.4　定义XML资源文件\n37.5　产生地图\n37.6　直接用程序定义界面组件\n37.7　控制地图\n37.8　添加缩放图标\n37.8.1　修改XML说明文件\n37.8.2　加上缩放控制（Zoom Controls）\n37.9　新版的改进\n37.10　参考资料\n第38章　添加按键控制（KeyEvent）\n38.1　添加菜单\n38.2　添加按键控制\n38.3　控制缩放范围\n38.4　参考文件\n第39章　获取现在位置（GPS\\/基站三角定位）\n39.1　创建新项目\n39.2　添加使用权限（uses-permission）\n39.3　定义LocationListener界面\n39.4　使用定位服务管理器（locationManager）来获取现在位置\n39.4.1　讲解\n39.4.2　自动判断最佳定位服务来源\n39.5　更新地点（Location Updates）\n39.6　在模拟器中切换地点\n39.7　完整的程序\n39.8　参考资料\n第40章　结合地图与定位功能（My LocationOverlay）\n40.1　添加定位层（MyLocation Overlay）\n40.2　参考资料\n第41章　为地图标上地标（Itemized Overlay）\n41.1　设置图标层（Itemized Overlay）\n41.2　添加图标层\n41.3　地图开发备忘列表\n41.4　参考资料\n后记\n附录A　如何取得范例源代码",
      "pages": "281",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s6089507.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s6089507.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s6089507.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/4127895\\/",
      "id": "4127895",
      "publisher": "人民邮电出版社",
      "isbn10": "7115213941",
      "isbn13": "9787115213945",
      "title": "Google Android开发入门指南",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/4127895",
      "alt_title": "",
      "author_intro": "",
      "summary": "《Google Android开发入门指南(第2版)》是一部关于Android开发的基础教程，采用由浅入深、循序渐进的方式讨论Android。《Google Android开发入门指南(第2版)》全部内容基于Android SDK1.5Windows、MacOS X、Linux平台适用Android开发入门的详细教程，适合Android与J2ME的初学者学习，以编写实例为教学主线，真正助您解决开发中遇到的诸多实际问题。\n书中还结合数独游戏等实例更加形象生动地讲解了Android开发的基本流程，且每章最后都有一个“快速阅读指南”，更加方便了读者的阅读。\n《Google Android开发入门指南(第2版)》有超过130个实务范例，全面深度地整合手机、网络及服务。\n《Google Android开发入门指南(第2版)》有易于阅读的架构设计，每个范例均搭配步骤及完成画面！范例完全兼容Android SDK 1.5。",
      "price": "45.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 36,
        "average": "8.6",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "罗升阳"
      ],
      "pubdate": "2012-10-1",
      "tags": [
        {
          "count": 213,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 67,
          "name": "android",
          "title": "android"
        },
        {
          "count": 45,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 32,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 31,
          "name": "内核",
          "title": "内核"
        },
        {
          "count": 27,
          "name": "Linux",
          "title": "Linux"
        },
        {
          "count": 25,
          "name": "软件开发",
          "title": "软件开发"
        },
        {
          "count": 21,
          "name": "计算机技术",
          "title": "计算机技术"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\\/mpic\\/s27280265.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "目录\n第1篇 初识Android系统\n第1章 准备知识 2\n1.1 Linux内核参考书籍 2\n1.2 Android应用程序参考书籍 3\n1.3 下载、编译和运行Android源代码 3\n1.3.1 下载Android源代码 4\n1.3.2 编译Android源代码 4\n1.3.3 运行Android模拟器 5\n1.4 下载、编译和运行Android内核源代码 6\n1.4.1 下载Android内核源代码 6\n1.4.2 编译Android内核源代码 7\n1.4.3 运行Android模拟器  8\n1.5 开发第一个Android应用程序 8\n1.6 单独编译和打包Android应用程序模块 11\n1.6.1 导入单独编译模块的mmm命令 11\n1.6.2 单独编译Android应用程序模块 12\n1.6.3 重新打包Android系统镜像文件 12\n第２章 硬件抽象层 13\n2.1 开发Android硬件驱动程序 4\n2.1.1 实现内核驱动程序模块 14\n2.1.2 修改内核Kconfig文件 21\n2.1.3 修改内核Makefile文件 22\n2.1.4 编译内核驱动程序模块 22\n2.1.5 验证内核驱动程序模块 23\n2.2 开发C可执行程序验证Android硬件驱动程序 24\n2.3 开发Android硬件抽象层模块 26\n2.3.1 硬件抽象层模块编写规范 26\n2.3.2 编写硬件抽象层模块接口 29\n2.3.3 硬件抽象层模块的加载过程 33\n2.3.4 处理硬件设备访问权限问题 36\n2.4 开发Android硬件访问服务 38\n2.4.1 定义硬件访问服务接口 38\n2.4.2 实现硬件访问服务 39\n2.4.3 实现硬件访问服务的JNI方法 40\n2.4.4 启动硬件访问服务 43\n2.5 开发Android应用程序来使用硬件访问服务 44\n第３章 智能指针 49\n3.1 轻量级指针 50\n3.1.1 实现原理分析 50\n3.1.2 应用实例分析 53\n3.2 强指针和弱指针 54\n3.2.1 强指针的实现原理分析 55\n3.2.2 弱指针的实现原理分析 61\n3.2.3 应用实例分析 67\n第2篇 Android专用驱动系统\n第４章 Logger日志系统 74\n4.1 Logger日志格式 75\n4.2 Logger日志驱动程序 76\n4.2.1 基础数据结构 77\n4.2.2 日志设备的初始化过程 78\n4.2.3 日志设备文件的打开过程 83\n4.2.4 日志记录的读取过程 84\n4.2.5 日志记录的写入过程 88\n4.3 运行时库层日志库 93\n4.4 C\\/C++日志写入接口 100\n4.5 Java日志写入接口 104\n4.6 Logcat工具分析 110\n4.6.1 相关数据结构 111\n4.6.2 初始化过程 115\n4.6.3 日志记录的读取过程 127\n4.6.4 日志记录的输出过程 132\n第５章 Binder进程间通信系统 144\n5.1 Binder驱动程序 145\n5.1.1 基础数据结构 146\n5.1.2 Binder设备的初始化过程 164\n5.1.3 Binder设备文件的打开过程 165\n5.1.4 Binder设备文件的内存映射过程 166\n5.1.5 内核缓冲区管理 173\n5.2 Binder进程间通信库 183\n5.3 Binder进程间通信应用实例 188\n5.4 Binder对象引用计数技术 196\n5.4.1 Binder本地对象的生命周期 197\n5.4.2 Binder实体对象的生命周期 201\n5.4.3 Binder引用对象的生命周期 204\n5.4.4 Binder代理对象的生命周期 209\n5.5 Binder对象死亡通知机制 212\n5.5.1 注册死亡接收通知 213\n5.5.2 发送死亡接收通知 216\n5.5.3 注销死亡接收通知 221\n5.6 Service Manager的启动过程 224\n5.6.1 打开和映射Binder设备文件 226\n5.6.2 注册为Binder上下文管理者 227\n5.6.3 循环等待Client进程请求 231\n5.7 Service Manager代理对象的获取过程 238\n5.8 Service组件的启动过程 244\n5.8.1 注册Service组件 245\n5.8.2 启动Binder线程池 289\n5.9 Service代理对象的获取过程 291\n5.10 Binder进程间通信机制的Java接口 300\n5.10.1 Service Manager的Java代理对象的获取过程 300\n5.10.2 Java服务接口的定义和解析 310\n5.10.3 Java服务的启动过程 313\n5.10.4 Java服务代理对象的获取过程 320\n5.10.5 Java服务的调用过程 323\n第６章 Ashmem匿名共享内存系统 327\n6.1 Ashmem驱动程序 328\n6.1.1 基础数据结构 328\n6.1.2 匿名共享内存设备的初始化过程 330\n6.1.3 匿名共享内存设备文件的打开过程 332\n6.1.4 匿名共享内存设备文件的内存映射过程 334\n6.1.5 匿名共享内存块的锁定和解锁过程 336\n6.1.6 匿名共享内存块的回收过程 344\n6.2 运行时库cutils的匿名共享内存访问接口 345\n6.3 匿名共享内存的C++访问接口 349\n6.3.1 MemoryHeapBase 349\n6.3.2 MemoryBase 359\n6.3.3 应用实例 364\n6.4 匿名共享内存的Java访问接口 370\n6.4.1 MemoryFile 370\n6.4.2 应用实例 375\n6.5 匿名共享内存的共享原理 386\n第3篇 Android应用程序框架\n第７章 Activity组件的启动过程 392\n7.1 Activity组件应用实例 392\n7.2 根Activity组件的启动过程 398\n7.3 子Activity组件在进程内的启动过程 432\n7.4 子Activity组件在新进程中的启动过程 440\n第８章 Service组件的启动过程 443\n8.1 Service组件应用实例 443\n8.2 Service组件在新进程中的启动过程 451\n8.3 Service组件在进程内的绑定过程 463\n第９章 Android系统广播机制 486\n9.1 广播机制应用实例 487\n9.2 广播接收者的注册过程 493\n9.3 广播的发送过程 501\n第10章 Content Provider组件的实现原理 524\n10.1 Content Provider组件应用实例 525\n10.1.1 ArticlesProvider 525\n10.1.2 Article 535\n10.2 Content Provider组件的启动过程 550\n10.3 Content Provider组件的数据共享原理 573\n10.3.1 数据共享模型 573\n10.3.2 数据传输过程 576\n10.4 Content Provider组件的数据更新通知机制 596\n10.4.1 注册内容观察者 597\n10.4.2 发送数据更新通知 603\n第11章 Zygote和System进程的启动过程 611\n11.1 Zygote进程的启动脚本  611\n11.2 Zygote进程的启动过程 614\n11.3 System进程的启动过程 622\n第12章 Android应用程序进程的启动过程 630\n12.1 应用程序进程的创建过程 630\n12.2 Binder线程池的启动过程 639\n12.3 消息循环的创建过程 641\n第13章 Android应用程序的消息处理机制 645\n13.1 创建线程消息队列 645\n13.2 线程消息循环过程 650\n13.3 线程消息发送过程 655\n13.4 线程消息处理过程 660\n第14章 Android应用程序的键盘消息处理机制 667\n14.1 键盘消息处理模型  667\n14.2 InputManager的启动过程  670\n14.2.1 创建InputManager 670\n14.2.2 启动InputManager 673\n14.2.3 启动InputDispatcher 675\n14.2.4 启动InputReader 677\n14.3 InputChannel的注册过程 688\n14.3.1 创建InputChannel 689\n14.3.2 注册Server端InputChannel 697\n14.3.3 注册系统当前激活的应用程序窗口 701\n14.3.4 注册Client端InputChannel 706\n14.4 键盘消息的分发过程 709\n14.4.1 InputReader获得键盘事件 710\n14.4.2 InputDispatcher分发键盘事件 717\n14.4.3 系统当前激活的应用程序窗口获得键盘消息 727\n14.4.4 InputDispatcher获得键盘事件处理完成通知 743\n14.5 InputChannel的注销过程 746\n14.5.1 销毁应用程序窗口 747\n14.5.2 注销Client端InputChannel 756\n14.5.3 注销Server端InputChannel 758\n第15章 Android应用程序线程的消息循环模型 764\n15.1 应用程序主线程消息循环模型 765\n15.2 与界面无关的应用程序子线程消息循环模型 766\n15.3 与界面相关的应用程序子线程消息循环模型 769\n第16章 Android应用程序的安装和显示过程 778\n16.1 应用程序的安装过程 778\n16.2 应用程序的显示过程 814",
      "pages": "830",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s27280265.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s27280265.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s27280265.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/19986441\\/",
      "id": "19986441",
      "publisher": "电子工业出版社",
      "isbn10": "7121181088",
      "isbn13": "9787121181085",
      "title": "Android系统源代码情景分析",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/19986441",
      "alt_title": "",
      "author_intro": "罗升阳，1984年出生，2007年毕业于浙江大学计算机系，取得学士学位，2010年毕业于上海交通大学计算机系，取得硕士学位。毕业后一直从事于互联网软件开发，并且致力于移动平台的研究，特别是对Android平台有深入的理解和研究。在国内知名IT技术社区CSDN上发表了数十篇高质量的Android系统原创性文章，并且开设博客专栏--《老罗的Android之旅》，积极与网友互动，深受大家喜爱，访问量一直居于前茅。",
      "summary": "在内容上，本书结合使用情景，全面、深入、细致地分析Android系统的源代码，涉及到Linux内核层、硬件抽象层（HAL）、运行时库层(Runtime)、应用程序框架层(Application Framework)以及应用程序层(Application)。\n在组织上，本书将上述内容划分为初识Android系统、Android专用驱动系统和Android应用程序框架三大篇章。初识Android系统篇介绍了参考书籍、基础知识以及实验环境搭建；Android专用驱动系统篇介绍了Logger日志驱动程序、Binder进程间通信驱动程序以及Ashmem匿名共享内存驱动程序；Android应用程序框架篇从组件、进程、消息以及安装四个维度来对Android应用程序的框架进行了深入的剖析。\n通过上述内容及其组织，本书能使读者既能从整体上把握Android系统的层次结构，又能从细节上去掌握每一个层次的要点。",
      "price": "109.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 70,
        "average": "8.1",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "柯元旦"
      ],
      "pubdate": "2011-9",
      "tags": [
        {
          "count": 143,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 92,
          "name": "Android内核",
          "title": "Android内核"
        },
        {
          "count": 35,
          "name": "Android、内核剖析、输入法框架分析、窗口管理系统、编译系",
          "title": "Android、内核剖析、输入法框架分析、窗口管理系统、编译系"
        },
        {
          "count": 27,
          "name": "内核剖析",
          "title": "内核剖析"
        },
        {
          "count": 22,
          "name": "Android,",
          "title": "Android,"
        },
        {
          "count": 19,
          "name": "框架",
          "title": "框架"
        },
        {
          "count": 18,
          "name": "操作系统",
          "title": "操作系统"
        },
        {
          "count": 18,
          "name": "android",
          "title": "android"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\\/mpic\\/s6937206.jpg",
      "binding": "",
      "translator": [],
      "catalog": "第1部分 基础篇\n第1章 linux基础\t2\n1.1 linux文件系统概述\t2\n1.2 linux启动过程\t4\n1.3 常用linux 命令\t6\n1.4 shell脚本备忘\t9\n1.4.1 获取输入\t10\n1.4.2 变量定义\t10\n1.4.3 条件判断\t11\n1.4.4 while []...do... done语句\t12\n1.4.5 for循环\t13\n1.4.6 函数\t14\n1.4.7 常用内置符号常量\t15\n1.5 make脚本备忘\t15\n1.5.1 一个简单的makefile文件\t16\n1.5.2 变量的定义与赋值\t18\n1.5.3 条件控制语句\t18\n1.5.4 宏（函数）定义\t19\n1.5.5 内置符号和变量\t22\n1.5.6 模板目标（pattern target）\t23\n1.5.7 目标特定的变量赋值（target-specific variable）\t24\n1.5.8 常用选项\t25\n第2章 java基础\t26\n2.1 类装载器dexclassloader\t26\n2.1.1 dexclassloader的调用方法\t27\n2.1.2 基于类装载器设计一种“插件”架构\t29\n2.2 jni调用机制\t32\n2.2.1 java访问c\t33\n2.2.2 c访问java\t35\n2.2.3 在c中使用持久对象\t37\n2.3 异步消息处理线程\t37\n2.3.1 实现异步线程的一般思路\t38\n2.3.2 android中异步线程的实现方法\t38\n第3章 android源码下载及开发环境配置\t44\n3.1 mac系统的配置\t44\n3.1.1 硬盘格式的配置\t44\n3.1.2 port的用法\t46\n3.2 在linux中配置usb连接\t46\n3.3 在eclipse中调试framework\t46\n3.3.1 一段防止下载异常的脚本\t47\n3.3.2 调试framework中的代码\t47\n第4章 使用git\t51\n4.1 安装git\t52\n4.2 git仓库管理\t52\n4.2.1 仓库的组成\t52\n4.2.2 创建仓库\t54\n4.2.3 分支管理\t55\n4.3 git merge用法\t57\n4.4 git rebase用法\t58\n4.5 git cherry-pick用法\t61\n4.6 git reset用法\t62\n4.7 恢复到无引用提交\t63\n4.8 git remote用法\t65\n4.9 git 配置\t67\n4.9.1 基本信息配置\t68\n4.9.2 merge、diff工具配置\t68\n4.9.3 .gitignore配置\t70\n4.10 同时使用git和svn\t71\n4.11 其他git常用命令示例\t72\n4.11.1 git branch\t72\n4.11.2 git checkout\t72\n4.11.3 git log\t73\n4.11.4 git commit --amend\t73\n4.11.5 git cherry-pick sha-1\t73\n4.11.6 git merge-base\t74\n4.11.7 git diff master…dev\t74\n4.11.8 git revert\t75\n4.11.9 git diff\t75\n4.11.10 git rm\t75\n4.11.11 git tag\t76\n第2部分 内核篇\n第5章 binder\t78\n5.1 binder框架\t78\n5.2 设计servier端\t80\n5.3 binder客户端设计\t81\n5.4 使用service类\t82\n5.4.1 获取binder对象\t82\n5.4.2 保证包裹内参数顺序aidl工具的使用\t83\n5.5 系统服务中的binder对象\t88\n5.5.1 servicemanager管理的服务\t88\n5.5.2 理解manager\t90\n第6章 framework概述\t92\n6.1 framework框架\t92\n6.1.1 服务端\t92\n6.1.2 客户端\t93\n6.1.3 linux驱动\t94\n6.2 apk程序的运行过程\t94\n6.3 客户端中的线程\t94\n6.4 几个常见问题\t95\n6.4.1 acitivity之间如何传递消息（数据）\t95\n6.4.2 窗口相关的概念\t96\n第7章 理解context\t98\n7.1 context是什么\t98\n7.2 一个应用程序中包含多少个context对象\t99\n7.3 context相关类的继承关系\t99\n7.4 创建context\t100\n7.4.1 application对应的context\t101\n7.4.2 activity对应的context\t102\n7.4.3 service对应的context\t103\n7.4.4 context之间的关系\t104\n第8章 创建窗口的过程\t106\n8.1 窗口的类型\t106\n8.2 token变量的含义\t108\n8.2.1 activity中的mtoken\t108\n8.2.2 window中的mapptoken\t109\n8.2.3 windowmanager.layoutparams中的token\t109\n8.2.4 view中的token\t110\n8.3 创建应用窗口\t111\n8.4 创建子窗口\t121\n8.4.1 dialog的创建\t122\n8.4.2 popupwindow的创建\t126\n8.4.3 contextmenu的创建\t127\n8.4.4 optionmenu的创建\t132\n8.5 系统窗口toast的创建\t136\n8.5.1 toast调用流程\t137\n8.5.2 toast添加窗口\t139\n8.6 创建窗口示例\t139\n第9章 framework的启动过程\t142\n9.1 framework运行环境综述\t142\n9.2 dalvik虚拟机相关的可执行程序\t143\n9.2.1 dalvikvm\t144\n9.2.2 dvz\t144\n9.2.3 app_process\t145\n9.3 zygote的启动\t147\n9.3.1 在init.rc中配置zygote启动参数\t147\n9.3.2 启动socket服务端口\t148\n9.3.3 加载preload-classes\t151\n9.3.4 加载preload-resources\t152\n9.3.5 使用folk启动新的进程\t152\n9.4 systemserver进程的启动\t155\n9.4.1 启动各种系统服务线程\t156\n9.4.2 启动第一个activity\t158\n第10章 ams内部原理\t160\n10.1 activity调度机制\t160\n10.1.1 几个重要概念\t161\n10.1.2 ams中的一些重要调度相关变量\t163\n10.1.3 startactivity()的流程\t165\n10.1.4 stopactivitylocked()停止activity\t183\n10.1.5 按“home”键回到桌面的过程\t186\n10.1.6 按“back”键回到上一个activity\t187\n10.1.7 长按“home”键\t189\n10.1.8 activity生命期的代码含义\t190\n10.2 内存管理\t192\n10.2.1 关闭而不退出\t192\n10.2.2 android与linux的配合\t194\n10.2.3 各种关闭程序的过程\t196\n10.2.4 释放内存详解\t197\n10.3 对ams中数据对象的理解\t211\n10.3.1 常见的对象操作\t212\n10.3.2 理解activity\t213\n10.3.3 android多进程吗，是同时在运行多个应用程序吗\t213\n10.4 activitygroup的内部机制\t214\n10.4.1 tabactivity使用时的类关系结构\t215\n10.4.2 localactivitymanager的内部机制\t217\n10.4.3 activitygroup内部的activity生命期控制\t220\n第11章 从输入设备中获取消息\t221\n11.1 android消息获取过程概述\t221\n11.2 与消息处理相关的源码文件分布\t223\n11.3 创建inputdispatcher线程\t226\n11.4 把窗口信息传递给inputdispatcher线程\t227\n11.5 创建inputchannel\t229\n11.6 在wms中注册inputchannel\t232\n11.7 在客户进程中注册inputchannel\t233\n11.8 wms中处理消息的时机\t234\n11.9 客户窗口获取消息的时机\t235\n第12章 屏幕绘图基础\t237\n12.1 绘制屏幕的软件架构\t237\n12.2 java客户端绘制调用过程\t239\n12.3 c客户端绘制过程\t241\n12.4 java客户端绘制相关类的关系\t244\n第13章 view工作原理\t247\n13.1 导论\t247\n13.2 用户消息类型\t249\n13.2.1 按键消息\t249\n13.2.2 触摸消息\t250\n13.3 按键消息派发过程\t252\n13.3.1 keyevent.dispatcherstate中的长按监测\t252\n13.3.2 按键消息总体派发过程\t254\n13.3.3 根视图内部派发过程\t256\n13.3.4 activity内部派发过程\t257\n13.3.5 view类内部的onkeydown()和onkeyup()\t260\n13.3.6 activity中的onkeydown()和onkeyup()\t261\n13.3.7 phonewindow内部消息派发过程\t262\n13.4 按键消息在wms中的派发过程\t263\n13.5 触摸消息派发过程\t266\n13.5.1 触摸消息总体派发过程\t266\n13.5.2 根视图内部消息派发过程\t267\n13.5.3 viewgroup内部消息派发过程\t268\n13.5.4 各种消息监测的基本实现方法\t271\n13.5.5 view内默认消息派发过程\t272\n13.6 导致view树重新遍历的时机\t274\n13.6.1 状态的分类\t274\n13.6.2 导致view树重新遍历的总体诱因图\t275\n13.6.3 refreshdrawablelist()\t276\n13.6.4 onfocusedchanged()\t278\n13.6.5 ensuretouchmode()\t279\n13.6.6 setvisibility()\t282\n13.6.7 setenable()\t284\n13.6.8 setselected()\t285\n13.6.9 invalidate()\t286\n13.6.10 requestfocus()\t290\n13.6.11 requestlayout()\t292\n13.7 遍历view树performtraversals()的执行过程\t293\n13.8 计算视图大小（measure）的过程\t296\n13.8.1 measure内部设计思路\t297\n13.8.2 viewgroup中的measurechildwithmargins()\t301\n13.8.3 linearlayout中的onmeasure()过程举例\t304\n13.9 布局（layout）过程\t308\n13.9.1 layout过程的设计思路\t308\n13.9.2 linearlayout中onlayout()内部过程\t309\n13.9.3 textview中gravity与layout的关系\t311\n13.10 绘制（draw）过程\t313\n13.10.1 视图中可绘制的元素\t313\n13.10.2 绘制过程的设计思路\t314\n13.10.3 viewroot中draw()的内部流程\t315\n13.10.4 view类中draw()函数内部流程\t318\n13.10.5 viewgroup类中绘制子视图dispatchdraw()内部流程\t322\n13.10.6 viewgroup类中drawchild()过程\t325\n13.10.7 绘制滚动条\t328\n13.11 动画的绘制\t331\n13.11.1 动画的设计思路\t332\n13.11.2 viewgroup类中drawchild()函数中视图动画绘制过程\t334\n13.11.3 viewgroup中dipsatchdraw()中布局动画绘制流程\t337\n第14章 wms工作原理\t340\n14.1 概述\t340\n14.1.1 窗口的定义\t340\n14.1.2 窗口管理要解决的核心问题\t341\n14.1.3 解决核心问题所使用的相关的变量列表\t343\n14.1.4 几个操作的概念\t346\n14.1.5 什么是policy，以及其与wms的关系\t346\n14.1.6 wms接口结构\t347\n14.2 wms主要内部类\t348\n14.2.1 表示窗口的数据类\t348\n14.2.2 dimanimator\t348\n14.2.3 fadeinoutanimation\t349\n14.2.4 inputmonitor类\t350\n14.2.5 policythread\t351\n14.2.6 session\t352\n14.2.7 watermark\t353\n14.2.8 wmthread\t354\n14.3 窗口的创建和删除\t355\n14.3.1 创建窗口的时机和过程\t355\n14.3.2 assignlayerslocked()的执行过程\t360\n14.3.3 addwindowtolistinorderlocked()的执行过程\t362\n14.3.4 删除窗口的时机\t364\n14.3.5 删除窗口的过程\t366\n14.3.6 removewindowinnerlocked()\t367\n14.4 计算窗口的大小\t371\n14.4.1 描述窗口尺寸的变量\t371\n14.4.2 窗口大小的变化过程\t372\n14.4.3 policy中layoutwindowlw()的执行过程\t375\n14.4.4 输入法窗口如何影响应用窗口的大小\t378\n14.5 切换窗口\t379\n14.5.1 切换要解决的问题\t379\n14.5.2 inputmanager和wms的接口\t381\n14.5.3 ams与wms的接口\t383\n14.5.4 从a到b的切换\t387\n14.5.5 从b回到a的过程\t390\n14.5.6 a中长按“home”键切换到b\t391\n14.5.7 setappvisiblity()与销毁surface\t393\n14.5.8 computefocusedwindowlocked()\t396\n14.6 perforlayoutandplacesurfaceslockedinner()的执行过程\t398\n14.6.1 总体过程\t399\n14.6.2 第一大步骤：计算窗口的大小\t401\n14.6.3 第二大步骤：计算窗口的可视状态\t401\n14.6.4 第三大步骤：通知surfaceflinger进行窗口重绘\t404\n14.7 窗口动画\t406\n14.8 屏幕旋转及configuration的变化过程\t409\n第3部分 系统篇\n第15章 资源访问机制\t414\n15.1 定义资源\t414\n15.2 存储资源\t415\n15.3 styleable、style、attr、theme的意义\t417\n15.4 attributeset与typedarray类\t420\n15.5 获取resources的过程\t425\n15.5.1 通过context获取\t425\n15.5.2 通过packagemanager获取\t429\n15.6 framework资源\t431\n15.6.1 加载和读取\t432\n15.6.2 添加\t434\n15.6.3 实现真正主题切换的两种思路\t436\n第16章 程序包管理（package manager service）\t439\n16.1 包管理概述\t439\n16.2 packages.xml文件格式\t442\n16.2.1 last-platform-version标签\t443\n16.2.2 permissions标签\t443\n16.2.3 cert标签\t444\n16.2.4 sigs标签\t444\n16.2.5 perms标签\t444\n16.2.6 package标签\t444\n16.2.7 shared-user标签\t445\n16.3 包管理服务的启动过程\t446\n16.3.1 各主要功能类的关系\t446\n16.3.2 pms主体启动过程\t448\n16.3.3 readpermission()内部过程\t450\n16.3.4 msettings.readlp()\t452\n16.3.5 scanpackageli()内部过程\t454\n16.3.6 msettings.writelp()\t455\n16.4 应用程序的安装和卸载\t455\n16.4.1 各主要功能类关系\t456\n16.4.2 应用程序安装过程\t457\n16.4.3 应用程序的卸载过程\t461\n16.5 intent匹配框架\t463\n16.5.1 主要功能类的关系\t463\n16.5.2 主体调用过程\t465\n第17章 输入法框架\t467\n17.1 输入法框架组成概述\t468\n17.2 输入法中各binder对象的创建过程\t469\n17.2.1 inputconnection\t469\n17.2.2 iinputmethodclient\t471\n17.2.3 inputmethodsession\t472\n17.2.4 inputmethod\t475\n17.3 输入法主要操作过程\t477\n17.3.1 输入法相关模块的启动过程\t477\n17.3.2 切换输入法\t478\n17.3.3 启动输入法\t480\n17.3.4 显示输入法\t485\n17.3.5 输入法操作过程中的重要变量总结\t489\n17.4 输入法窗口内部的显示过程\t490\n17.4.1 ims中的showwindow()的内部执行过程\t491\n17.4.2 标准布局的ims\t496\n17.4.3 自定义布局的ims\t502\n17.5 向编辑框传递字符\t503\n17.6 输入法相关源码清单\t504\n第4部分 编译篇\n第18章 android编译系统\t508\n18.1 android源码文件结构\t509\n18.2 从调用make命令开始说起\t509\n18.2.1 编译命令\t510\n18.2.2 编译结构猜想\t510\n18.3 编译所需脚本文件之间的协同关系\t512\n18.3.1 编译系统内部功能模块图\t512\n18.3.2 脚本文件的包含关系\t514\n18.3.3 从子项目中提取编译目标\t518\n18.3.4 生成编译规则\t519\n18.3.5 设置编译输出目录\t521\n18.3.6 生成最终的image文件\t522\n18.4 如何增加一个product\t523\n18.4.1 什么是一个product\t523\n18.4.2 如何增加一个product\t527\n18.5 如何增加一个项目\t528\n18.5.1 项目类别和项目路径\t529\n18.5.2 添加一个c项目\t530\n18.5.3 添加一个apk项目\t531\n18.6 apk编译过程\t533\n18.6.1 总体编译过程概述\t533\n18.6.2 生成r.java\t535\n18.6.3 编译aidl文件\t536\n18.6.4 包含java静态库\t536\n18.6.5 编译java源文件生成jar包\t538\n18.6.6 将jar包转换为dex文件\t539\n18.6.7 编译资源文件生成apk包\t540\n18.6.8 将dex文件添加到apk包中\t541\n18.6.9 添加jni所需的动态库文件\t541\n18.6.10 对apk文件进行签名\t543\n18.6.11 使用zipalign优化apk内部存储\t543\n18.7 framework的编译\t544\n18.7.1 总体编译过程\t544\n18.7.2 framework\\/core\\/ext三个jar文件的区别\t546\n18.8 编译android.jar\t547\n18.8.1 资源文件\t547\n18.8.2 aidl文件\t551\n18.8.3 java文件\t551\n18.9 编译adt插件\t553\n18.10 总结\t554\n第19章 编译自己的rom\t555\n19.1 嵌入式系统的内存地址空间\t555\n19.2 各种映像（image）文件的作用\t559\n19.3 编译nexus s（ns）的image文件\t562\n19.3.1 编译linux kernel\t562\n19.3.2 提取ns的私有驱动文件\t563\n19.3.3 编译system.img文件\t564\n19.3.4 创建ramdisk.img\t565\n19.3.5 创建boot.img文件\t566\n19.4 使用fastboot写入image文件\t566\n19.5 最后验证\t567\n19.5.1 解决触摸按键问题\t568\n19.5.2 解决音量和电源键\t568\n19.5.3 wifi问题\t570\n19.5.4 安装google mobile service（gms）\t571\n第5部分 硬件驱动篇\n第20章 基于ti omap处理器的 techshine 开发板介绍\t573\n20.1 techv-35xx开发板概述\t574\n20.2 交叉编译环境配置\t575\n20.3 x-loader编译\t578\n20.4 u-boot编译\t578\n20.5 techv-35xx linux驱动和内核配置及编译\t579\n20.5.1 touchscreen驱动配置\t579\n20.5.2 keyboard驱动配置\t580\n20.5.3 audio驱动配置\t581\n20.5.4 4mmc\\/sd驱动配置\t582\n20.5.5 nandflash驱动配置\t582\n20.5.6 lcd驱动配置\t583\n20.5.7 内核编译\t583\n20.6 techv-35xx android驱动编写\t584\n20.7 techv-35xx android开发环境建立\t589\n20.8 编译android donut\t590\n20.9 android根文件系统的制作\t591\n20.10 相关image文件的烧写\t591\n20.11 android 根文件系统安装\t593",
      "pages": "595",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s6937206.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s6937206.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s6937206.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/6811238\\/",
      "id": "6811238",
      "publisher": "电子工业出版社",
      "isbn10": "7121143984",
      "isbn13": "9787121143984",
      "title": "Android内核剖析",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/6811238",
      "alt_title": "",
      "author_intro": "柯元旦，1981年生于陕西咸阳，2003年毕业于西安电子科技大学通信工程学院；2003～2006年，创立了一家设计公司，提供便携式媒体播放器解决方案，基于TI DSP芯片自主开发了一套操作系统，包括任务管理与调度、文件系统及GUI(图形用户接口)等：2006～2009年，就职于联想研究院，先后从事嵌入式系统设计以及互联网应用开发；2009年至今，从事Android应用程序开发和Framework内核研究，对Android内核有较深刻的理解。",
      "summary": "由柯元旦编著的《Android内核剖析》详细分析了Android内核的内部机制，包括窗口管理系统、Activity管理系统、输入法框架、编译系统等，为Android内核定制及高级应用程序开发提供技术参考。\n    《Android内核剖析》适合于所有Android相关的工程师及产品经理，还可作为相关培训机构的教材。",
      "price": "79.90元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 138,
        "average": "8.6",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[美] Bill Phillips",
        "[美] Brian Hardy"
      ],
      "pubdate": "2014-4-1",
      "tags": [
        {
          "count": 156,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 99,
          "name": "android",
          "title": "android"
        },
        {
          "count": 68,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 37,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 36,
          "name": "移动开发",
          "title": "移动开发"
        },
        {
          "count": 21,
          "name": "软件开发",
          "title": "软件开发"
        },
        {
          "count": 9,
          "name": "图灵,android",
          "title": "图灵,android"
        },
        {
          "count": 9,
          "name": "程序设计",
          "title": "程序设计"
        }
      ],
      "origin_title": "Android programming: the big nerd ranch guide",
      "image": "https://img3.doubanio.com\\/mpic\\/s28342615.jpg",
      "binding": "平装",
      "translator": [
        "王明发"
      ],
      "catalog": "第1章　Android应用初体验　　1\n1.1 　应用基础　　2\n1.2 　创建Android项目　　2\n1.3 　Eclipse工作区导航　　5\n1.4 　用户界面设计　　6\n1.4.1 　视图层级结构　　9\n1.4.2 　组件属性　　10\n1.4.3 　创建字符串资源　　11\n1.4.4 　预览界面布局　　12\n1.5 　从布局XML到视图对象　　13\n1.6 　组件的实际应用　　15\n1.6.1 　类包组织导入　　16\n1.6.2 　引用组件　　16\n1.6.3 　设置监听器　　17\n1.7 　使用模拟器运行应用　　21\n1.8 　Android编译过程　　22\n第2章　Android与MVC设计模式　　26\n2.1 　创建新类　　26\n2.2 　Android与MVC设计模式　　30\n2.3 　更新视图层　　31\n2.4 　更新控制层　　33\n2.5 　在设备上运行应用　　37\n2.5.1 　连接设备　　37\n2.5.2 　配置设备用于应用开发　　38\n2.6 　添加图标资源　　38\n2.6.1 　向项目中添加资源　　39\n2.6.2 　在XML文件中引用资源　　40\n2.7 　关于挑战练习　　41\n2.8 　挑战练习一：为TextView添加监听器　　41\n2.9 　挑战练习二：添加后退按钮　　42\n2.10 　挑战练习三：从按钮到图标按钮　　42\n第3章　Activity的生命周期　　45\n3.1 　日志跟踪理解Activity生命周期　　46\n3.1.1 　输出日志信息　　46\n3.1.2 　使用 LogCat　　48\n3.2 　设备旋转与Activity生命周期　　52\n3.3 　设备旋转前保存数据　　56\n3.4 　再探Activity生命周期　　57\n3.5 　深入学习：测试onSaveInstanceState-(Bundle)方法　　59\n3.6 　深入学习：日志记录的级别与方法　　60\n第4章　Android应用的调试　　62\n4.1 　DDMS应用调试透视图　　63\n4.2 　异常与栈跟踪　　64\n4.2.1 　诊断应用异常　　65\n4.2.2 　记录栈跟踪日志　　66\n4.2.3 　设置断点　　68\n4.2.4 　使用异常断点　　71\n4.3 　文件浏览器　　72\n4.4 　Android特有的调试工具　　73\n4.4.1 　使用Android Lint　　73\n4.4.2 　R类的问题　　74\n第5章　第二个activity　　75\n5.1 　创建第二个activity　　76\n5.1.1 　创建新布局　　77\n5.1.2 　创建新的activity子类　　80\n5.1.3 　在manifest配置文件中声明activity　　81\n5.1.4 　为QuizActivity添加cheat按钮　　82\n5.2 　启动activity　　83\n5.3 　activity间的数据传递　　85\n5.3.1 　使用intent extra　　86\n5.3.2 　从子activity获取返回结果　　88\n5.4 　activity的使用与管理　　92\n5.5 　挑战练习　　95\n第6章　Android SDK版本与兼容　　96\n6.1 　Android SDK版本　　96\n6.2 　Android编程与兼容性问题　　97\n6.2.1 　全新的系统版本——Honeycomb　　97\n6.2.2 　SDK最低版本　　99\n6.2.3 　SDK目标版本　　99\n6.2.4 　SDK编译版本　　99\n6.2.5 　安全添加新版本API中的代码　　100\n6.3 　使用Android开发者文档　　103\n6.4 　挑战练习：报告编译版本　　105\n第7章　UI fragment与fragment 管理器　　106\n7.1 　UI设计的灵活性需求　　107\n7.2 　fragment的引入　　107\n7.3 　着手开发CriminalIntent　　108\n7.3.1 　创建新项目　　110\n7.3.2 　fragment与支持库　　112\n7.3.3 　创建Crime类　　113\n7.4 　托管UI fragment　　115\n7.4.1 　fragment的生命周期　　115\n7.4.2 　托管的两种方式　　116\n7.4.3 　定义容器视图　　116\n7.5 　创建UI fragment　　117\n7.5.1 　定义CrimeFragment的布局　　118\n7.5.2 　创建CrimeFragment类　　119\n7.6 　添加UI fragment到FragmentManager　　122\n7.6.1 　fragment事务　　123\n7.6.2 　FragmentManager与fragment生命周期　　125\n7.7 　activity使用fragment的理由　　127\n7.8 　深入学习：Honeycomb、ICS、Jelly Bean以及更高版本系统上的应用开发　　127\n第8章　使用布局与组件创建用户界面　　128\n8.1 　升级Crime类　　128\n8.2 　更新布局　　129\n8.3 　生成并使用组件　　131\n8.4 　深入探讨XML布局属性　　132\n8.4.1 　样式、主题及主题属性　　132\n8.4.2 　dp、sp以及屏幕像素密度　　133\n8.4.3 　Android开发设计原则　　134\n8.4.4 　布局参数　　135\n8.4.5 　边距与内边距　　135\n8.5 　使用图形布局工具　　136\n8.5.1 　添加新组件　　138\n8.5.2 　属性视图中编辑组件属性　　138\n8.5.3 　在框架视图中重新组织组件　　139\n8.5.4 　更新子组件的布局参数　　140\n8.5.5　　android:layout_weight属性的工作原理　　141\n8.5.6 　图形布局工具使用总结　　142\n8.5.7 　组件ID与多种布局　　142\n8.6 　挑战练习：日期格式化　　143\n第9章　使用ListFragment显示列表　　144\n9.1 　更新CriminalIntent应用的模型层　　145\n9.2 　创建ListFragment　　147\n9.3 　使用抽象activity托管fragment　　149\n9.3.1 　通用的fragment托管布局　　149\n9.3.2 　抽象activity类　　150\n9.4 　ListFragment、ListView及ArrayAdapter　　154\n9.4.1 　创建ArrayAdapter<T>类实例　　157\n9.4.2 　响应列表项的点击事件　　159\n9.5 　定制列表项　　160\n9.5.1 　创建列表项布局　　160\n9.5.2 　创建adapter子类　　162\n第10章　使用fragment argument　　165\n10.1 　从fragment中启动activity　　165\n10.1.1 　附加extra信息　　166\n10.1.2 　获取extra信息　　167\n10.1.3 　使用Crime数据更新CrimeFragment视图　　167\n10.1.4 　直接获取extra信息方式的缺点　　169\n10.2 　fragment argument　　169\n10.2.1 　附加argument给fragment　　169\n10.2.2 　获取argument　　170\n10.3 　重新加载显示列表项　　171\n10.4 　通过fragment获取返回结果　　172\n第11章　使用ViewPager　　174\n11.1 　创建CrimePagerActivity　　175\n11.1.1 　以代码的方式定义并产生布局　　176\n11.1.2 　ViewPager与Pager-Adapter　　177\n11.1.3 　整合配置并使用CrimePagerActivity　　178\n11.1.4 　FragmentStatePager-Adapter与Fragment-PagerAdapter　　180\n11.2 　深入学习：ViewPager的工作原理　　182\n第12章　对话框　　184\n12.1 　创建DialogFragment　　186\n12.1.1 　显示DialogFragment　　187\n12.1.2 　设置对话框的显示内容　　188\n12.2 　fragment间的数据传递　　190\n12.2.1 　传递数据给DatePicker-Fragment　　191\n12.2.2 　返回数据给CrimeFragment　　193\n12.3 　挑战练习：更多对话框　　198\n第13章　使用MediaPlayer播放音频　　199\n13.1 　添加资源　　200\n13.2 　定义HelloMoonFragment布局文件　　202\n13.3 　创建HelloMoonFragment　　203\n13.4 　使用布局fragment　　204\n13.5 　音频播放　　205\n13.6 　挑战练习：暂停音频播放　　208\n13.7 　深入学习：播放视频　　208\n13.8 　挑战练习：在HelloMoon应用中播放视频　　208\n第14章　fragment的保留　　209\n14.1 　保留fragment实例　　209\n14.2 　设备旋转与保留的fragment　　210\n14.3 　保留的fragment：一切都完美了吗　　212\n14.4 　设备旋转处理与onSaveInstance-State(Bundle)方法　　212\n14.5 　深入学习：fragment引入前的设备旋转问题　　214\n第15章　应用本地化　　215\n15.1 　本地化资源　　215\n15.2 　配置修饰符　　216\n15.2.1 　可用资源优先级排定　　217\n15.2.2 　多重配置修饰符　　218\n15.2.3 　寻找最匹配的资源　　219\n15.3 　更多资源使用原则及控制　　220\n15.3.1 　资源命名　　220\n15.3.2 　资源目录结构　　220\n15.4 　测试备选资源　　221\n第16章　操作栏　　223\n16.1 　选项菜单　　223\n16.1.1 　在XML文件中定义选项菜单　　225\n16.1.2 　创建选项菜单　　227\n16.1.3 　响应菜单项选择　　230\n16.2 　实现层级式导航　　232\n16.2.1 　启用应用图标的导航功能　　232\n16.2.2 　响应向上按钮　　233\n16.3 　可选菜单项　　236\n16.3.1 　创建可选菜单XML文件　　236\n16.3.2 　切换菜单项标题　　237\n16.3.3 　“还有个问题”　　238\n16.4 　挑战练习：用于列表的空视图　　239\n第17章　存储与加载本地文件　　241\n17.1 　CriminalIntent应用的数据存取　　241\n17.1.1 　保存crime数据到JSON文件　　242\n17.1.2 　从文件中读取crime数据　　246\n17.2 　挑战练习：使用外部存储　　248\n17.3 　深入学习：Android文件系统与Java I\\/O　　248\n第18章　上下文菜单与上下文操作模式　　250\n18.1 　定义上下文菜单资源　　251\n18.2 　实施浮动上下文菜单　　251\n18.2.1 　创建上下文菜单　　251\n18.2.2 　为上下文菜单登记视图　　252\n18.2.3 　响应菜单项选择　　253\n18.3 　实施上下文操作模式　　254\n18.3.1 　实现列表视图的多选操作　　255\n18.3.2 　列表视图中的操作模式回调方法　　256\n18.3.3 　改变已激活视图的显示背景　　258\n18.3.4 　实现其他视图的上下文操作模式　　259\n18.4 　兼容性问题：回退还是复制　　260\n18.5 　挑战练习：在CrimeFragment视图中删除crime记录　　261\n18.6 　深入学习：ActionBarSherlock　　261\n18.7 　挑战练习：使用ActionBarSherlock　　263\n18.7.1 　CriminalIntent应用中ABS的基本整合　　264\n18.7.2 　ABS的深度整合　　264\n18.7.3 　ABS的完全整合　　265\n第19章　相机I：取景器　　266\n19.1 　创建Fragment布局　　267\n19.2 　创建CrimeCameraFragment　　269\n19.3 　创建CrimeCameraActivity　　269\n19.4 　使用相机API　　271\n19.4.1 　打开并释放相机　　271\n19.4.2 　SurfaceView、Surface-Holder与Surface　　272\n19.4.3 　确定预览界面大小　　276\n19.4.4 　启动CrimeCamera-Activity　　277\n19.5 　深入学习：以命令行的方式运行activity　　281\n第20章　相机 II：拍摄并处理照片　　283\n20.1 　拍摄照片　　283\n20.1.1 　实现相机回调方法　　285\n20.1.2 　设置图片尺寸大小　　288\n20.2 　返回数据给CrimeFragment　　288\n20.2.1 　以接收返回值的方式启动CrimeCameraActivity　　289\n20.2.2 　在CrimeCameraFragment中设置返回值　　290\n20.2.3 　在CrimeFragment中获取照片文件名　　290\n20.3 　更新模型层　　291\n20.3.1 　新增Photo类　　292\n20.3.2 　为Crime添加photo属性　　293\n20.3.3 　设置photo属性　　293\n20.4 　更新CrimeFragment的视图　　294\n20.4.1 　添加ImageView组件　　295\n20.4.2 　图像处理　　296\n20.5 　在DialogFragment中显示大图片　　300\n20.6 　挑战练习：Crime照片的显示方向　　303\n20.7 　挑战练习：删除照片　　303\n20.8 　深入学习：Android代码的废弃处理　　303\n第21章　隐式intent　　305\n21.1 　添加按钮组件　　306\n21.2 　添加嫌疑人信息至模型层　　307\n21.3 　使用格式化字符串　　308\n21.4 　使用隐式intent　　309\n21.4.1 　典型隐式intent的组成　　310\n21.4.2 　发送陋习报告　　311\n21.4.3 　获取联系人信息　　313\n21.4.4 　检查可以响应的activity　　316\n21.5 　挑战练习：又一个隐式intent　　317\n第22章　Master-Detail用户界面　　318\n22.1 　增加布局灵活性　　319\n22.1.1 　修改SingleFragment-Activity　　320\n22.1.2 　创建包含两个fragment容器的布局　　320\n22.1.3 　使用别名资源　　322\n22.2 　Activity：fragment的托管者　　323\n22.3 　深入学习：设备屏幕尺寸的确定　　331\n第23章　深入学习intent和任务　　333\n23.1 　创建NerdLauncher项目　　333\n23.2 　解析隐式intent　　334\n23.3 　在运行时创建显式intent　　337\n23.4 　任务与后退栈　　338\n23.5 　使用NerdLauncher应用作为设备主屏幕　　341\n23.6 　挑战练习：应用图标与任务重排　　341\n23.7 　进程与任务　　341\n第24章　样式与include标签的使用　　343\n24.1 　创建RemoteControl项目　　344\n24.1.1 　编码实现RemoteControl-Activity　　344\n24.1.2 　创建RemoteControl-Fragment　　345\n24.2 　使用样式消除重复代码　　348\n24.3 　完善布局定义　　350\n24.4 　深入学习：使用include与merge标签　　353\n24.5 　挑战练习：样式的继承　　354\n第25章　XML Drawable与9-Patches　　355\n25.1 　XML drawable　　356\n25.2 　state list drawable　　358\n25.3 　layer list与inset drawable　　360\n25.4 　使用9-patch图像　　362\n第26章　HTTP与后台任务　　368\n26.1 　创建PhotoGallery应用　　369\n26.2 　网络连接基本　　372\n26.3 　使用AsyncTask在后台线程上运行代码　　373\n26.4 　线程与主线程　　375\n26.5 　获取Flickr XML数据　　377\n26.6 　从AsyncTask回到主线程　　382\n26.7 　深入学习：再探AsyncTask　　385\n26.8 　挑战练习：分页　　386\n第27章　Looper、Handler与HandlerThread　　387\n27.1 　设置GridView以显示图片　　387\n27.2 　批量下载缩略图　　390\n27.3 　与主线程通信　　390\n27.4 　创建并启动后台线程　　391\n27.5 　Message与message Handler　　393\n27.5.1 　消息的剖析　　393\n27.5.2 　Handler的剖析　　393\n27.5.3 　使用handler　　395\n27.5.4 　传递handler　　397\n27.6 　深入学习：AsyncTask与Thread　　401\n27.7 　挑战练习：预加载以及缓存　　401\n第28章　搜索　　402\n28.1 　搜索Flickr网站　　402\n28.2 　搜索对话框　　404\n28.2.1 　创建搜索界面　　404\n28.2.2 　可搜索的activity　　406\n28.2.3 　物理搜索键　　408\n28.2.4 　搜索的工作原理　　409\n28.2.5 　启动模式与新的intent　　410\n28.2.6 　使用shared preferences实现轻量级数据存储　　412\n28.3 　在Android 3.0以后版本的设备上使用SearchView　　414\n28.4 　挑战练习　　416\n第29章　后台服务　　417\n29.1 　创建IntentService　　417\n29.2 　服务的作用　　419\n29.3 　查找最新返回结果　　421\n29.4 　使用AlarmManager延迟运行服务　　422\n29.4.1 　PendingIntent　　424\n29.4.2 　使用PendingIntent管理定时器　　424\n29.5 　控制定时器　　425\n29.6 　通知信息　　428\n29.7 　深入学习：服务细节内容　　429\n29.7.1 　服务的能与不能　　430\n29.7.2 　服务的生命周期　　430\n29.7.3 　non-sticky服务　　430\n29.7.4 　sticky服务　　431\n29.7.5 　绑定服务　　431\n第30章　broadcast Intent　　433\n30.1 　随设备重启而重启的定时器　　433\n30.1.1 　配置文件中的broadcast receiver　　434\n30.1.2 　如何使用receiver　　435\n30.2 　过滤前台通知消息　　436\n30.2.1 　发送broadcast intent　　437\n30.2.2 　动态broadcast receiver　　437\n30.2.3 　使用私有权限　　440\n30.2.4 　使用ordered broadcast接收结果　　442\n30.3 　receiver与长时运行任务　　446\n第31章　网页浏览　　447\n31.1 　最后一段Flickr数据　　447\n31.2 　简单方式：使用隐式intent　　448\n31.3 　较难方式：使用WebView　　449\n31.3.1 　使用WebChromeClient优化WebView的显示　　453\n31.3.2 　处理WebView的设备旋转问题　　455\n31.4 　深入学习：注入JavaScript对象　　456\n第32章　定制视图与触摸事件　　457\n32.1 　创建DragAndDraw项目　　457\n32.1.1 　创建DragAndDraw-Activity　　458\n32.1.2 　创建DragAndDraw-Fragment　　459\n32.2 　创建定制视图　　460\n32.3 　处理触摸事件　　462\n32.4 　onDraw(...)方法内的图形绘制　　465\n32.5 　挑战练习：设备旋转问题　　467\n第33章　跟踪设备的地理位置　　468\n33.1 　启动RunTracker项目　　468\n33.1.1 　创建RunActivity　　469\n33.1.2 　创建RunFragment　　470\n33.2 　地理位置与LocationManager　　472\n33.3 　接收定位数据更新broadcast　　474\n33.4 　使用定位数据刷新UI显示　　475\n33.5 　快速定位：最近一次地理位置　　479\n33.6 　在物理和虚拟设备上测试地理位置定位　　480\n第34章　使用SQLite本地数据库　　482\n34.1 　在数据库中存储旅程和地理位置信息　　482\n34.2 　查询数据库中的旅程列表　　488\n34.3 　使用CursorAdapter显示旅程列表　　490\n34.4 　创建新旅程　　493\n34.5 　管理现有旅程　　494\n34.6 　挑战练习：识别当前跟踪的旅程　　500\n第35章　使用Loader加载异步数据　　501\n35.1 　Loader与LoaderManager　　501\n35.2 　在RunTracker应用中使用Loader　　502\n35.3 　加载旅程列表　　503\n35.4 　加载单个旅程　　506\n35.5 　加载旅程的最近一次地理位置　　509\n第36章　使用地图　　511\n36.1 　添加Maps API给RunTracker应用　　511\n36.1.1 　使用物理设备测试地图　　511\n36.1.2 　安装使用Google Play services SDK　　511\n36.1.3 　获取Google Maps API key　　512\n36.1.4 　更新RunTracker应用的manifest配置文件　　512\n36.2 　在地图上显示用户的地理位置　　513\n36.3 　显示旅程路线　　516\n36.4 　为旅程添加开始和结束地图标注　　520\n36.5 　挑战练习：实时数据更新　　521\n第37章　编后语　　522\n37.1 　终极挑战　　522\n37.2 　关于我们　　523\n37.3 　致谢　　523",
      "pages": "523",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s28342615.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s28342615.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s28342615.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/25848404\\/",
      "id": "25848404",
      "publisher": "人民邮电出版社",
      "isbn10": "7115346437",
      "isbn13": "9787115346438",
      "title": "Android编程权威指南",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/25848404",
      "alt_title": "Android programming: the big nerd ranch guide",
      "author_intro": "作者简介：\nBill Phillips\nBig Nerd Ranch资深Android讲师、高级软件工程师。他与Brian Hardy合作，为Big Nerd Ranch开发了广受好评的5天Android训练营培训课程。Bill擅长透彻地理解事物的本质，并帮助其他人做到这一点。闲暇时间，Bill喜欢阅读和弹钢琴。\nBrian Hardy\nBig Nerd Ranch首席软件工程师、资深讲师。Big Nerd Ranch的Android、iOS和Ruby培训课程均由Brian设计开发。闲暇时间，Brian喜欢骑自行车和听音乐。",
      "summary": "权威、全面、实用、易懂，是本书最大的特色。本书根据美国大名鼎鼎的Big Nerd Ranch训练营的Android培训讲义编写而成，已经为微软、谷歌、Facebook等行业巨头培养了众多专业人才。作者巧妙地把Android开发所需的庞杂知识、行业实践、编程规范等融入一本书中，通过精心编排的应用示例、循序渐进的内容组织，以及循循善诱的语言，深入地讲解了Android开发的方方面面。如果学完一章之后仍然意犹未尽，那“挑战练习”一定会让你大呼过瘾。本书之所以能在移动应用开发类图书中脱颖而出，还在于它真的是在与读者“对话”。阅读本书就好像有一位私人导师在你身边随时为你答疑解惑。\n本书适合所有对Android及移动开发感兴趣的读者，需要一定的Java编程基础。",
      "series": {
        "id": "13846",
        "title": "The Big Nerd Ranch Guide"
      },
      "price": "CNY 99.00"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 194,
        "average": "7.5",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "李刚"
      ],
      "pubdate": "2011-6",
      "tags": [
        {
          "count": 176,
          "name": "android",
          "title": "android"
        },
        {
          "count": 48,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 46,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 43,
          "name": "android开发",
          "title": "android开发"
        },
        {
          "count": 37,
          "name": "疯狂android讲义",
          "title": "疯狂android讲义"
        },
        {
          "count": 32,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 20,
          "name": "程序开发",
          "title": "程序开发"
        },
        {
          "count": 15,
          "name": "实用",
          "title": "实用"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s6641009.jpg",
      "binding": "",
      "translator": [],
      "catalog": "第1章 android应用与开发环境\t1\n1.1 android的发展和历史\t2\n1.1.1 android的发展和简介\t2\n1.1.2 android平台架构及特性\t3\n1.2 搭建android开发环境\t5\n1.2.1 下载和安装android sdk\t5\n1.2.2 安装eclipse和adt插件\t7\n1.3 android常用开发工具的用法\t10\n1.3.1 创建、删除和浏览avd\t10\n1.3.2 使用android模拟器\n（emulator）\t14\n1.3.3 使用ddms进行调试\t15\n1.3.4 android debug bridge（adb）\n的用法\t16\n1.3.5 使用dx编译android应用\t18\n1.3.6 使用android asset packaging\ntool（aapt）打包资源\t19\n1.3.7 使用mksdcard管理虚拟sd卡\t19\n1.4 开始第一个android应用\t20\n1.4.1 使用eclipse开发第一个\nandroid应用\t20\n1.4.2 通过adt运行android应用\t23\n1.5 android应用结构分析\t24\n1.5.1 创建一个android应用\t24\n1.5.2 自动生成的r.java\t26\n1.5.3 res目录说明\t27\n1.5.4 android应用的清单文件：\nandroidmanifest.xml\t28\n1.5.5 应用程序权限说明\t29\n1.6 android应用的基本组件\n介绍\t31\n1.6.1 activity和view\t31\n1.6.2 service\t32\n1.6.3 broadcastreceiver\t32\n1.6.4 contentprovider\t32\n1.6.5 intent和intentfilter\t33\n1.7 本章小结\t33\n第2章 android应用的界面编程\t35\n2.1 界面编程与视图（view）组件\t36\n2.1.1 视图组件与容器组件\t36\n2.1.2 使用xml布局文件控制ui\n界面\t40\n2.1.3 在代码中控制ui界面\t41\n2.1.4 使用xml布局文件和java\n代码混合控制ui界面\t42\n2.1.5 开发自定义view\t43\n2.2 布局管理器\t46\n2.2.1 线性布局\t47\n2.2.2 表格布局\t49\n2.2.3 帧布局\t52\n2.2.4 相对布局\t55\n2.2.5 绝对布局\t58\n2.3 基本界面组件\t60\n2.3.1 文本框（textview）与编辑框\n（edittext）的功能和用法\t60\n2.3.2 按钮（button）与图片按钮（imagebutton）组件的功能和\n用法\t66\n2.3.3 使用9patch图片作为按钮背景\t68\n2.3.4 单选按钮（radiobutton）和复选\n框（checkbox）介绍与应用\t69\n2.3.5 状态开关按钮（togglebutton）\n的功能与用法\t71\n2.3.6 时钟（analogclock和digital\nclock）的功能与功法\t73\n2.3.7 图像视图（imageview）的\n功能和用法\t75\n2.4 高级界面组件\t79\n2.4.1 自动完成文本框（autocompletetextview）的\n功能和用法\t79\n2.4.2 spinner的功能和用法\t80\n2.4.3 日期、时间选择器（datepicker\n和timepicker）的功能和用法\t83\n2.4.4 进度条（progressbar）的\n功能和用法\t85\n2.4.5 拖动条（seekbar）的功能和\n用法\t90\n2.4.6 星级评分条（ratingbar）的\n功能和用法\t91\n2.4.7 选项卡（tabhost）的功能和\n用法\t93\n2.4.8 滚动视图（scrollview）的\n功能和用法\t95\n2.4.9 列表视图（listview和\nlistactivity）\t95\n2.4.10 可展开的列表组件（expandablelistview）\t101\n2.4.11 网格视图（gridview）和\n图像切换器（imageswitcher）\n功能和用法\t104\n2.4.12 画廊视图（gallery）的功能和\n用法\t107\n2.5 对话框\t110\n2.5.1 使用alertdialog创建简单\n对话框\t110\n2.5.2 使用alertdialog创建列表\n对话框\t112\n2.5.3 使用alertdialog创建自定义\n对话框\t116\n2.5.4 使用popupwindow\t121\n2.5.5 使用datepickerdialog、timepickerdialog\t123\n2.5.6 使用progressdialog创建进度\n对话框\t125\n2.6 消息提示\t127\n2.6.1 使用toast显示提示信息框\t128\n2.6.2 notification的功能与用法\t129\n2.7 菜单\t132\n2.7.1 选项菜单和子菜单\n（submenu）\t132\n2.7.2 使用监听器来监听菜单事件\t136\n2.7.3 创建复选菜单项和单选菜单项\t137\n2.7.4 设置与菜单项关联的activity\t140\n2.7.5 上下文菜单\t141\n2.8 本章小结\t143\n第3章 事件处理\t144\n3.1 android的事件处理\t145\n3.2 基于监听的事件处理\t145\n3.2.1 事件监听的处理模型\t145\n3.2.2 事件和事件监听器\t148\n3.2.3 内部类作为事件监听器类\t151\n3.2.4 外部类作为事件监听器类\t152\n3.2.5 activity本身作为事件监听器\t153\n3.2.6 匿名内部类作为事件监听器类\t154\n3.2.7 直接绑定到标签\t155\n3.3 基于回调的事件处理\t156\n3.3.1 回调机制与监听机制\t156\n3.3.2 基于回调的事件传播\t158\n3.3.3 重写ontouchevent方法响应\n触摸屏事件\t160\n3.4 响应的系统设置的事件\t162\n3.4.1 configuration类简介\t162\n3.4.2 重写onconfigurationchanged\n响应系统设置更改\t164\n3.5 handler消息传递机制\t166\n3.5.1 handler类简介\t166\n3.5.2 handler使用案例\t167\n3.6 本章小结\t168\n第4章 深入理解activity\t169\n4.1 建立、配置和使用activity\t170\n4.1.1 建立activity\t170\n4.1.2 配置activity\t177\n4.1.3 启动、关闭activity\t179\n4.1.4 使用bundle在activity之间\n交换数据\t181\n4.1.5 启动其他activity并返回结果\t185\n4.2 activity的回调机制\t189\n4.3 activity的生命周期\t190\n4.3.1 activity的生命周期演示\t190\n4.3.2 activity与servlet的相似性与\n区别\t194\n4.4 本章小结\t195\n第5章 使用intent和intentfilter\n第5章 进行通信\t196\n5.1 intent对象详解\t197\n5.1.1 使用intent启动系统组件\t197\n5.2 intent的属性及intent-filter\n配置\t198\n5.2.1 component属性\t198\n5.2.2 action、category属性与\nintent-filter配置\t200\n5.2.3 指定action、category调用\n系统activity\t204\n5.2.4 data、type属性与intent-filter\n配置\t209\n5.2.5 extra属性\t211\n5.3 使用intent创建tab页面\t211\n5.4 本章小结\t212\n第6章 android应用的资源\t213\n6.1 资源的类型及存储方式\t214\n6.1.1 资源的类型以及存储方式\t214\n6.1.2 使用资源\t216\n6.2 使用字符串、颜色、\n尺寸资源\t217\n6.2.1 颜色值的定义\t217\n6.2.2 定义字符串、颜色、尺寸资源\n文件\t218\n6.2.3 使用字符串、颜色、\n尺寸资源\t219\n6.3 数组（array）资源\t222\n6.4 使用（drawable）资源\t225\n6.4.1 图片资源\t225\n6.4.2 statelistdrawable资源\t225\n6.4.3 layerdrawable资源\t227\n6.4.4 shapedrawable资源\t229\n6.4.5 clipdrawable资源\t231\n6.4.6 animationdrawable资源\t233\n6.5 使用原始xml资源\t236\n6.5.1 定义原始xml资源\t236\n6.5.2 使用原始xml文件\t237\n6.6 使用布局（layout）资源\t239\n6.7 使用菜单（menu）资源\t239\n6.7.1 定义菜单资源\t239\n6.7.2 使用菜单资源\t240\n6.8 样式（style）和主题（theme）\n资源\t243\n6.8.1 样式资源\t243\n6.8.2 主题资源\t245\n6.9 属性（attribute）资源\t247\n6.10 使用原始资源\t249\n6.11 国际化和资源自适应\t251\n6.11.1 java国际化的思路\t252\n6.11.2 java支持的语言和国家\t252\n6.11.3 完成程序国际化\t253\n6.11.4 为android应用提供国际化\n资源\t255\n6.11.5 国际化android应用\t256\n6.12 本章小结\t258\n第7章 图形与图像处理\t259\n7.1 使用简单图片\t260\n7.1.1 使用drawable对象\t260\n7.1.2 bitmap和bitmapfactory\t260\n7.2 绘图\t263\n7.2.1 android绘图基础：canvas、\npaint等\t263\n7.2.2 path类\t267\n7.2.3 绘制游戏动画\t270\n7.3 图形特效处理\t278\n7.3.1 使用matrix控制变换\t278\n7.3.2 使用drawbitmapmesh扭曲\n图像\t282\n7.3.3 使用shader填充图形\t285\n7.4 逐帧（frame）动画\t288\n7.4.1 animationdrawable与逐帧\n动画\t288\n7.5 补间（tween）动画\t292\n7.5.1 tween动画与interpolator\t292\n7.5.2 位置、大小、旋转度、透明度\n改变的补间动画\t293\n7.5.3 自定义补间动画\t298\n7.6 使用surfaceview实现动画\t300\n7.6.1 surfaceview的绘图机制\t301\n7.7 本章小结\t305\n第8章 android的数据存储和io\t306\n8.1 使用sharedpreferences\t307\n8.1.1 sharedpreferences与editor\n简介\t307\n8.1.2 sharedpreferences的存储\n位置和格式\t308\n8.1.3 读、写其他应用shared\npreferences\t310\n8.2 file存储\t311\n8.2.1 openfileoutput和open\nfileinput\t312\n8.2.2 读写sd卡上的文件\t314\n8.3 sqlite数据库\t321\n8.3.1 简介sqlitedatabase\t321\n8.3.2 创建数据库和表\t323\n8.3.3 使用sql语句操作sqlite\n数据库\t323\n8.3.4 使用sqlite3工具\t325\n8.3.5 使用特定方法操作sqlite\n数据库\t327\n8.3.6 事务\t329\n8.3.7 sqliteopenhelper类\t330\n8.4 手势（gesture）\t335\n8.4.1 手势检测\t335\n8.4.2 增加手势\t342\n8.4.3 识别用户的手势\t346\n8.5 自动朗读（tts）\t347\n8.6 本章小结\t350\n第9章 使用contentprovider实现\n第9章 数据共享\t351\n9.1 数据共享标准：\ncontentprovider简介\t352\n9.1.1 contentprovider简介\t352\n9.1.2 uri简介\t353\n9.1.3 使用contentresolver操作\n数据\t354\n9.2 操作系统的contentprovider\t355\n9.2.1 使用contentprovider管理\n联系人\t355\n9.2.2 使用contentprovider管理\n多媒体内容\t360\n9.3 实现contentprovider\t364\n9.3.1 创建contentprovider的步骤\t364\n9.4 监听contentprovider的数据\n改变\t370\n9.4.1 contentobserver简介\t370\n9.5 本章小结\t372\n第10章 service与broadcast\n第10章 receiver\t373\n10.1 service简介\t374\n10.1.1 创建、配置service\t374\n10.1.2 启动和停止service\t376\n10.1.3 绑定本地service并与之\n通信\t377\n10.1.4 service的生命周期\t381\n10.2 跨进程调用service\n（aidl服务）\t382\n10.2.1 aidl服务简介\t382\n10.2.2 创建aidl文件\t383\n10.2.3 将接口暴露给客户端\t383\n10.2.4 客户端访问aidlservice\t385\n10.3 电话管理器\n（telephonymanager）\t393\n10.4 短信管理器（smsmanager）\t400\n10.5 音频管理器\n（audiomanager）\t404\n10.5.1 audiomanager简介\t404\n10.6 振动器（vibrator）\t407\n10.6.1 vibrator简介\t407\n10.6.2 使用vibrator控制手机振动\t407\n10.7 手机闹钟服务\n（alarmmanager）\t408\n10.7.1 alarmmanager简介\t408\n10.7.2 设置闹钟\t409\n10.8 接收广播消息\t413\n10.8.1 broadcastreceiver简介\t413\n10.8.2 发送广播\t414\n10.8.3 有序广播\t416\n10.9 接收系统广播消息\t424\n10.10 本章小结\t427\n第11章 多媒体应用开发\t428\n11.1 音频和视频的播放\t429\n11.1.1 使用mediaplayer播放音频\t429\n11.1.2 使用soundpool播放音效\t432\n11.1.3 使用videoview播放视频\t435\n11.1.4 使用mediaplayer和\nsurfaceview播放视频\t436\n11.2 使用mediarecorder录制\n音频\t439\n11.3 控制摄像头拍照\t442\n11.3.1 通过camera进行拍照\t442\n11.3.2 录制视频短片\t446\n11.4 本章小结\t450\n第12章 opengl与3d应用开发\t451\n12.1 3d图像与3d开发的\n基本知识\t452\n12.2 opengl和opengl es简介\t453\n12.3 绘制2d图形\t454\n12.3.1 在android应用中使用\nopengl es\t454\n12.3.2 绘制平面上的多边形\t457\n12.3.3 旋转\t463\n12.4 绘制3d图形\t465\n12.4.1 构建3d图形\t465\n12.4.2 应用纹理贴图\t469\n12.5 本章小结\t475\n第13章 android的网络应用\t476\n13.1 基于tcp协议的网络通信\t477\n13.1.1 tcp协议基础\t477\n13.1.2 使用serversocket创建\ntcp服务器端\t478\n13.1.3 使用socket进行通信\t479\n13.1.4 加入多线程\t483\n13.2 使用url访问网络资源\t488\n13.2.1 使用url读取网络资源\t489\n13.2.2 使用urlconnection\n提交请求\t490\n13.3 使用http访问网络\t496\n13.3.1 使用httpurlconnection\t496\n13.3.2 使用apache httpclient\t501\n13.4 使用webview视图\n显示网页\t505\n13.4.1 使用webview浏览网页\t506\n13.4.2 使用webview加载html\n代码\t507\n13.5 使用web service进行\n网络编程\t508\n13.5.1 web service简介\t509\n13.5.2 web service平台概述\t510\n13.5.3 使用android应用调用\nweb service\t512\n13.6 本章小结\t524\n第14章 管理android手机桌面\t525\n14.1 管理手机桌面\t526\n14.1.1 删除桌面组件\t526\n14.1.2 添加桌面组件\t526\n14.2 改变手机壁纸\t527\n14.2.1 开发实时壁纸\n（live wallpapers）\t528\n14.3 桌面快捷方式\t532\n14.3.1 在桌面上创建快捷方式\t532\n14.3.2 向launcher添加快捷方式\t534\n14.4 管理桌面小控件\t535\n14.5 实时文件夹（livefolder）\t539\n14.5.1 使用实时文件夹显示\ncontentprovider的数据\t540\n14.6 本章小结\t545\n第15章 传感器应用开发\t546\n15.1 利用android的传感器\t547\n15.1.1 开发传感器应用\t547\n15.1.2 下载和安装sensorsimulator\t549\n15.1.3 利用sensorsimulator开发\n传感器应用\t551\n15.2 android的常用传感器\t553\n15.2.1 方向传感器orientation\t553\n15.2.2 磁场传感器magnetic field\t554\n15.2.3 温度传感器temperature\t554\n15.2.4 光传感器light\t554\n15.2.5 压力传感器pressure\t554\n15.3 传感器应用案例\t557\n15.4 本章小结\t564\n第16章 gps应用开发\t565\n16.1 支持gps的核心api\t566\n16.2 获取locationprovider\t568\n16.2.1 获取所有可用的\nlocationprovider\t568\n16.2.2 通过名称获得指定\nlocationprovider\t569\n16.2.3 根据criteria获得\nlocationprovider\t569\n16.3 获取定位信息\t570\n16.3.1 通过模拟器发送gps信息\t571\n16.3.2 获取定位数据\t571\n16.4 临近警告\t573\n16.5 本章小结\t575\n第17章 使用google map服务\t576\n17.1 调用google map的准备\t577\n17.1.1 获取map api key\t577\n17.1.2 创建支持google map api的\navd\t580\n17.2 根据gps信息在地图上\n定位\t582\n17.3 gps导航\t588\n17.4 根据地址定位\t590\n17.4.1 地址解析与反向地址解析\t590\n17.4.2 根据地址定位\t595\n17.5 本章小结\t597\n第18章 疯狂连连看\t598\n18.1 连连看游戏简介\t599\n18.2 开发游戏界面\t600\n18.2.1 开发界面布局\t600\n18.2.2 开发游戏界面组件\t601\n18.2.3 处理方块之间的连接线\t605\n18.3 连连看的状态数据模型\t606\n18.3.1 定义数据模型\t606\n18.3.2 初始化游戏状态数据\t606\n18.4 加载界面的图片\t610\n18.5 实现游戏activity\t612\n18.6 实现游戏逻辑\t618\n18.6.1 定义gameservice组件接口\t618\n18.6.2 实现gameservice组件\t619\n18.6.3 获取触碰点的方块\t620\n18.6.4 判断两个方块是否可以相连\t622\n18.6.5 定义获取通道的工具方法\t623\n18.6.6 没有转折点的横向连接\t625\n18.6.7 没有转折点的纵向连接\t626\n18.6.8 一个转折点的连接\t626\n18.6.9 两个转折点的连接\t629\n18.6.10 找出最短距离\t636\n18.7 本章小结\t638\n第19章 电子拍卖系统\t639\n19.1 系统功能简介和架构设计\t640\n19.1.1 系统功能简介\t640\n19.1.2 系统架构设计\t641\n19.2 json简介\t643\n19.2.1 使用json语法创建对象\t643\n19.2.2 使用json语法创建数组\t644\n19.2.3 java的json支持\t645\n19.3 发送请求的工具类\t646\n19.4 用户登录\t647\n19.4.1 处理登录的servlet\t648\n19.4.2 用户登录\t649\n19.5 查看流拍物品\t655\n19.5.1 查看流拍物品的servlet\t655\n19.5.2 查看流拍物品\t656\n19.6 管理物品种类\t661\n19.6.1 浏览物品种类的servlet\t661\n19.6.2 查看物品种类\t662\n19.6.3 添加种类的servlet\t666\n19.6.4 添加物品种类\t666\n19.7 管理拍卖物品\t668\n19.7.1 查看自己的拍卖物品的\nservlet\t668\n19.7.2 查看自己的拍卖物品\t669\n19.7.3 添加拍卖物品的servlet\t672\n19.7.4 添加拍卖物品\t673\n19.8 参与竞拍\t678\n19.8.1 选择物品种类\t678\n19.8.2 根据种类浏览物品的servlet\t680\n19.8.3 根据种类浏览物品\t680\n19.8.4 参与竞价的servlet\t682\n19.8.5 参与竞价\t683\n19.9 权限控制\t688\n19.10 本章小结\t689",
      "pages": "689",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s6641009.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s6641009.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s6641009.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/6515839\\/",
      "id": "6515839",
      "publisher": "电子工业出版社",
      "isbn10": "7121135760",
      "isbn13": "9787121135767",
      "title": "疯狂Android讲义",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/6515839",
      "alt_title": "",
      "author_intro": "作者从事过近7年的J2EE应用开发，担任过LITEON公司的J2EE技术主管，负责该公司的企业信息平台的架构设计，担任过广东龙泉科技有限公司的J2EE技术培训导师，目前在新东方IT培训中心担任J2EE培训讲师。培训的学生已在华为、从兴电子、瑞达通信、中企动力等公司就职，在珠三角的J2EE行业极具影响力。",
      "summary": "计算机便携化是未来的发展趋势，而Android作为最受欢迎的手机、平\n板电脑操作之一，其发展的上升势头是势不可当的。而Android应用选择了\nJava作为其开发语言，对于Java来说也是一次极好的机会。\n    李刚编著的《疯狂Android讲义》全面地介绍了Android应用开发的相\n关知识，全书内容覆盖了Android用户界面编程、Android四大组件、\nAndroid资源访问、图形\\/图像处理、事件处理机制、Android输入\\/输出处\n理、音频\\/视频多媒体应用开发、OpenGL与3D应用开发、网络通信编程、\nAndroid平台的Web Service、传感器应用开发、GPS应用开发、Google Map\n服务等。\n    《疯狂Android讲义》并不局限于介绍Android编程的各种理论知识，\n而是从“项目驱动”的角度来讲授理论，全书一共包括近百个实例，这些\n示范性的实例既可帮读者更好地理解各知识点在实际开发中的应用，也可\n供读者在实际开发时作为参考、拿来就用。本书最后还提供了两个实用的\n案例：疯狂连连看和电子拍卖系统Android客户端，具有极高的参考价值。\n本书提供了配套的答疑网站，如果读者在阅读本书时遇到了技术问题，可\n以登录疯狂Java联盟（http:\\/\\/www.crazyit.org）发帖，笔者将会及时予\n以解答。\n    本书适合于有一定Java编程基础的读者。如果读者已熟练掌握Java编\n程语法并具有一定图形界面编程经验，阅读本书将十分合适。否则，阅读\n本书之前建议先认真阅读疯狂Java体系之《疯狂Java讲义》。",
      "price": "89.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 74,
        "average": "8.4",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "丰生强"
      ],
      "pubdate": "2013-2",
      "tags": [
        {
          "count": 180,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 108,
          "name": "安全",
          "title": "安全"
        },
        {
          "count": 80,
          "name": "逆向工程",
          "title": "逆向工程"
        },
        {
          "count": 33,
          "name": "移动开发",
          "title": "移动开发"
        },
        {
          "count": 22,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 21,
          "name": "android",
          "title": "android"
        },
        {
          "count": 18,
          "name": "计算机安全",
          "title": "计算机安全"
        },
        {
          "count": 14,
          "name": "编程",
          "title": "编程"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s24870013.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "第1章 　Android程序分析环境搭建　　1\n1.1 　Windows分析环境搭建　　1\n1.1.1 　安装JDK　　1\n1.1.2 　安装Android SDK　　3\n1.1.3 　安装Android NDK　　5\n1.1.4 　Eclipse集成开发环境　　6\n1.1.5 　安装CDT、ADT插件　　6\n1.1.6 　创建Android Virtual Device　　8\n1.1.7 　使用到的工具　　9\n1.2 　Linux分析环境搭建　　9\n1.2.1 　本书的Linux环境　　9\n1.2.2 　安装JDK　　9\n1.2.3 　在Ubuntu上安装Android SDK　　10\n1.2.4 　在Ubuntu上安装Android NDK　　11\n1.2.5 　在Ubuntu上安装Eclipse集成开发环境　　12\n1.2.6 　在Ubuntu上安装CDT、ADT插件　　13\n1.2.7 　创建Android Virtual Device　　13\n1.2.8 　使用到的工具　　15\n1.3 　本章小结　　15\n第2章 　如何分析Android程序　　16\n2.1 　编写第一个Android程序　　16\n2.1.1 　使用Eclipse创建Android工程　　16\n2.1.2 　编译生成APK文件　　19\n2.2 　破解第一个程序　　20\n2.2.1 　如何动手？　　20\n2.2.2 　反编译APK文件　　20\n2.2.3 　分析APK文件　　21\n2.2.4 　修改Smali文件代码　　26\n2.2.5 　重新编译APK文件并签名　　26\n2.2.6 　安装测试　　27\n2.3 　本章小结　　28\n第3章 　进入Android Dalvik虚拟机　　29\n3.1 　Dalvik虚拟机的特点——掌握Android程序的运行原理　　29\n3.1.1 　Dalvik虚拟机概述　　29\n3.1.2 　Dalvik虚拟机与Java虚拟机的区别　　29\n3.1.3 　Dalvik虚拟机是如何执行程序的　　34\n3.1.4 　关于Dalvik虚拟机JIT（即时编译）　　36\n3.2 　Dalvik汇编语言基础为分析Android程序做准备　　37\n3.2.1 　Dalvik指令格式　　37\n3.2.2 　DEX文件反汇编工具　　39\n3.2.3 　了解Dalvik寄存器　　40\n3.2.4 　两种不同的寄存器表示方法——v命名法与p命名法　　42\n3.2.5 　Dalvik字节码的类型、方法与字段表示方法　　43\n3.3 　Dalvik指令集　　44\n3.3.1 　指令特点　　45\n3.3.2 　空操作指令　　45\n3.3.3 　数据操作指令　　46\n3.3.4 　返回指令　　46\n3.3.5 　数据定义指令　　46\n3.3.6 　锁指令　　47\n3.3.7 　实例操作指令　　47\n3.3.8 　数组操作指令　　48\n3.3.9 　异常指令　　48\n3.3.10 　跳转指令　　48\n3.3.11 　比较指令　　49\n3.3.12 　字段操作指令　　50\n3.3.13 　方法调用指令　　50\n3.3.14 　数据转换指令　　51\n3.3.15 　数据运算指令　　51\n3.4 　Dalvik指令集练习——写一个Dalvik版的Hello World　　52\n3.4.1 　编写smali文件　　52\n3.4.2 　编译smali文件　　54\n3.4.3 　测试运行　　54\n3.5 　本章小结　　55\n第4章 　Android可执行文件　　56\n4.1 　Android程序的生成步骤　　56\n4.2 　Android程序的安装流程　　59\n4.3 　dex文件格式　　66\n4.3.1 　dex文件中的数据结构　　66\n4.3.2 　dex文件整体结构　　68\n4.3.3 　dex文件结构分析　　71\n4.4 　odex文件格式　　80\n4.4.1 　如何生成odex文件　　80\n4.4.2 　odex文件整体结构　　81\n4.4.3 　odex文件结构分析　　83\n4.5 　dex文件的验证与优化工具dexopt的工作过程　　88\n4.6 　Android应用程序另类破解方法　　91\n4.7 　本章小结　　93\n第5章 　静态分析Android程序　　94\n5.1 　什么是静态分析　　94\n5.2 　快速定位Android程序的关键代码　　94\n5.2.1 　反编译apk程序　　94\n5.2.2 　程序的主Activity　　95\n5.2.3 　需重点关注的Application类　　95\n5.2.4 　如何定位关键代码——六种方法　　96\n5.3 　smali文件格式　　97\n5.4 　Android程序中的类　　100\n5.4.1 　内部类　　100\n5.4.2 　监听器　　102\n5.4.3 　注解类　　105\n5.4.4 　自动生成的类　　108\n5.5 　阅读反编译的smali代码　　110\n5.5.1 　循环语句　　110\n5.5.2 　switch分支语句　　115\n5.5.3 　try\\/catch语句　　121\n5.6 　使用IDA Pro静态分析Android程序　　127\n5.6.1 　IDA Pro对Android的支持　　127\n5.6.2 　如何操作　　128\n5.6.3 　定位关键代码——使用IDA Pro进行破解的实例　　132\n5.7 　恶意软件分析工具包——Androguard　　135\n5.7.1 　Androguard的安装与配置　　135\n5.7.2 　Androguard的使用方法　　137\n5.7.3 　使用Androguard配合Gephi进行静态分析　　144\n5.7.4 　使用androlyze.py进行静态分析　　148\n5.8 　其他静态分析工具　　152\n5.9 　阅读反编译的Java代码　　152\n5.9.1 　使用dex2jar生成jar文件　　152\n5.9.2 　使用jd-gui查看jar文件的源码　　153\n5.10 　集成分析环境——santoku　　154\n5.11 　本章小结　　156\n第6章 　基于Android的ARM汇编语言基础——逆向原生！　　157\n6.1 　Android与ARM处理器　　157\n6.1.1 　ARM处理器架构概述　　157\n6.1.2 　ARM处理器家族　　158\n6.1.3 　Android支持的处理器架构　　159\n6.2 　原生程序与ARM汇编语言——逆向你的原生Hello ARM　　160\n6.2.1 　原生程序逆向初步　　160\n6.2.2 　原生程序的生成过程　　162\n6.2.3 　必须了解的ARM知识　　164\n6.3 　ARM汇编语言程序结构　　166\n6.3.1 　完整的ARM汇编程序　　166\n6.3.2 　处理器架构定义　　167\n6.3.3 　段定义　　168\n6.3.4 　注释与标号　　169\n6.3.5 　汇编器指令　　169\n6.3.6 　子程序与参数传递　　170\n6.4 　ARM处理器寻址方式　　170\n6.4.1 　立即寻址　　170\n6.4.2 　寄存器寻址　　171\n6.4.3 　寄存器移位寻址　　171\n6.4.4 　寄存器间接寻址　　171\n6.4.5 　基址寻址　　171\n6.4.6 　多寄存器寻址　　171\n6.4.7 　堆栈寻址　　172\n6.4.8 　块拷贝寻址　　172\n6.4.9 　相对寻址　　172\n6.5 　ARM与Thumb指令集　　173\n6.5.1 　指令格式　　173\n6.5.2 　跳转指令　　174\n6.5.3 　存储器访问指令　　175\n6.5.4 　数据处理指令　　177\n6.5.5 　其他指令　　184\n6.6 　用于多媒体编程与浮点计算的NEON与VFP指令集　　185\n6.7 　本章小结　　186\n第7章 　Android NDK程序逆向分析　　187\n7.1 　Android中的原生程序　　187\n7.1.1 　编写一个例子程序　　187\n7.1.2 　如何编译原生程序　　188\n7.2 　原生程序的启动流程分析　　194\n7.2.1 　原生程序的入口函数　　194\n7.2.2 　main函数究竟何时被执行　　198\n7.3 　原生文件格式　　199\n7.4 　原生C程序逆向分析　　200\n7.4.1 　原生程序的分析方法　　200\n7.4.2 　for循环语句反汇编代码的特点　　204\n7.4.3 　if...else分支语句反汇编代码的特点　　208\n7.4.4 　while循环语句反汇编代码的特点　　211\n7.4.5 　switch分支语句反汇编代码的特点　　215\n7.4.6 　原生程序的编译时优化　　218\n7.5 　原生C++程序逆向分析　　222\n7.5.1 　C++类的逆向　　222\n7.5.2 　Android NDK对C++特性的支持　　225\n7.5.3 　静态链接STL与动态链接STL的代码区别　　227\n7.6 　Android NDK JNI API逆向分析　　232\n7.6.1 　Android NDK提供了哪些函数　　232\n7.6.2 　如何静态分析Android NDK程序　　233\n7.7 　本章小结　　235\n第8章 　动态调试Android程序　　236\n8.1 　Android动态调试支持　　236\n8.2 　DDMS的使用　　237\n8.2.1 　如何启动DDMS　　237\n8.2.2 　使用LogCat查看调试信息　　238\n8.3 　定位关键代码　　240\n8.3.1 　代码注入法——让程序自己吐出注册码　　240\n8.3.2 　栈跟踪法　　244\n8.3.3 　Method Profiling　　247\n8.4 　使用AndBug调试Android程序　　250\n8.4.1 　安装AndBug　　251\n8.4.2 　使用AndBug　　251\n8.5 　使用IDA Pro调试Android原生程序　　254\n8.5.1 　调试Android原生程序　　255\n8.5.2 　调试Android原生动态链接库　　256\n8.6 　使用gdb调试Android原生程序　　260\n8.6.1 　编译gdb与gdbserver　　260\n8.6.2 　如何调试　　262\n8.7 　本章小结　　264\n第9章 　Android软件的破解技术　　265\n9.1 　试用版软件　　265\n9.1.1 　试用版软件的种类　　265\n9.1.2 　实例破解——针对授权KEY方式的破解　　265\n9.2 　序列号保护　　271\n9.3 　网络验证　　272\n9.3.1 　网络验证保护思路　　272\n9.3.2 　实例破解——针对网络验证方式的破解　　273\n9.4 　In-app Billing（应用内付费）　　277\n9.4.1 　In-app Billing原理　　277\n9.4.2 　In-app Billing破解方法　　280\n9.5 　Google Play License保护　　281\n9.5.1 　Google Play License保护机制　　281\n9.5.2 　实例破解——针对Google Play License方式的破解　　283\n9.6 　重启验证　　284\n9.6.1 　重启验证保护思路　　285\n9.6.2 　实例破解——针对重启验证方式的破解　　285\n9.7 　如何破解其他类型的Android程序　　296\n9.7.1 　Mono for Android开发的程序及其破解方法　　296\n9.7.2 　Qt for Android开发的程序及其破解方法　　301\n9.8 　本章小结　　309\n第10章 　Android程序的反破解技术　　310\n10.1 　对抗反编译　　310\n10.1.1 　如何对抗反编译工具　　310\n10.1.2 　对抗dex2jar　　311\n10.2 　对抗静态分析　　312\n10.2.1 　代码混淆技术　　312\n10.2.2 　NDK保护　　315\n10.2.3 　外壳保护　　316\n10.3 　对抗动态调试　　316\n10.3.1 　检测调试器　　316\n10.3.2 　检测模拟器　　317\n10.4 　防止重编译　　318\n10.4.1 　检查签名　　318\n10.4.2 　校验保护　　319\n10.5 　本章小结　　320\n第11章 　Android系统攻击与防范　　321\n11.1 　Android系统安全概述　　321\n11.2 　手机ROOT带来的危害　　321\n11.2.1 　为什么要ROOT手机　　321\n11.2.2 　手机ROOT后带来的安全隐患　　322\n11.2.3 　Android手机ROOT原理　　322\n11.3 　Android权限攻击　　329\n11.3.1 　Android权限检查机制　　329\n11.3.2 　串谋权限攻击　　333\n11.3.3 　权限攻击检测　　336\n11.4 　Android组件安全　　339\n11.4.1 　Activity安全及Activity劫持演示　　340\n11.4.2 　Broadcast Receiver 安全　　343\n11.4.3 　Service安全　　345\n11.4.4 　Content Provider安全　　346\n11.5 　数据安全　　347\n11.5.1 　外部存储安全　　347\n11.5.2 　内部存储安全　　348\n11.5.3 　数据通信安全　　350\n11.6 　ROM安全　　351\n11.6.1 　ROM的种类　　352\n11.6.2 　ROM的定制过程　　352\n11.6.3 　定制ROM的安全隐患　　359\n11.6.4 　如何防范　　360\n11.7 　本章小结　　361\n第12章 　DroidKongFu变种病毒实例分析　　362\n12.1 　DroidKongFu病毒介绍　　362\n12.2 　配置病毒分析环境　　363\n12.3 　病毒执行状态分析　　364\n12.3.1 　使用APIMonitor初步分析　　365\n12.3.2 　使用DroidBox动态分析　　369\n12.3.3 　其他动态分析工具　　373\n12.4 　病毒代码逆向分析　　376\n12.4.1 　Java层启动代码分析　　376\n12.4.2 　Native层启动代码分析　　381\n12.4.3 　Native层病毒核心分析　　393\n12.5 　DroidKongFu病毒框架总结　　404\n12.6 　病毒防治　　406\n12.7 　本章小结　　406",
      "pages": "407",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s24870013.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s24870013.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s24870013.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/20556210\\/",
      "id": "20556210",
      "publisher": "人民邮电出版社",
      "isbn10": "7115308152",
      "isbn13": "9787115308153",
      "title": "Android软件安全与逆向分析",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/20556210",
      "alt_title": "",
      "author_intro": "丰生强（网名非虫）\nAndroid软件安全专家。看雪论坛Android安全版版主；安卓巴士开发交流版版主。\n对Android软件与系统安全有狂热的爱好和独到的见解，对Android系统的全部源代码进行过深入地研究和分析。逆向分析实战经验丰富。\n在国内信息安全杂志上发表过多篇有价值的软件安全文章，目前就职于国内某Android开发企业，常年混迹于看雪论坛（ID非虫）。\n作者邮箱：fei_cong@hotmail.com\n愿与国内安全爱好者共同交流与探讨安全技术。",
      "summary": "本书由浅入深、循序渐进地讲解了Android 系统的软件安全、逆向分析与加密解密技术。包括Android软件逆向分析和系统安全方面的必备知识及概念、如何静态分析Android 软件、如何动态调试Android 软件、Android 软件的破解与反破解技术的探讨，以及对典型Android 病毒的全面剖析。\n本书适合所有Android 应用开发者、Android 系统开发工程师、Android 系统安全工作者阅读学习。",
      "series": {
        "id": "13000",
        "title": "图灵原创"
      },
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 57,
        "average": "7.0",
        "min": 0
      },
      "subtitle": "系统卷",
      "author": [
        "杨丰盛"
      ],
      "pubdate": "2011-6",
      "tags": [
        {
          "count": 151,
          "name": "android",
          "title": "android"
        },
        {
          "count": 40,
          "name": "技术内幕",
          "title": "技术内幕"
        },
        {
          "count": 38,
          "name": "源码分析",
          "title": "源码分析"
        },
        {
          "count": 34,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 26,
          "name": "移动平台",
          "title": "移动平台"
        },
        {
          "count": 26,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 25,
          "name": "软件开发",
          "title": "软件开发"
        },
        {
          "count": 21,
          "name": "计算机科学",
          "title": "计算机科学"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s6379378.jpg",
      "binding": "平装",
      "translator": [],
      "catalog": "前言\n第1章  准备工作 \\/1\n1.1  深入认识Android \\/2\n1.1.1  Android的系统构架 \\/2\n1.1.2  Android的初始化流程 \\/5\n1.1.3  各个层次之间的相互关系 \\/8\n1.1.4  Android系统开发（移植）和应用开发 \\/11\n1.2  获取和编译Android的源码 \\/13\n1.2.1  环境配置 \\/13\n1.2.2  获取Android源码 \\/14\n1.2.3  编译Android的源码及其工具包 \\/16\n1.2.4  运行Android系统 \\/21\n1.3  开发环境搭建 \\/23\n1.3.1  应用开发环境搭建 \\/23\n1.3.2  源码开发环境搭建 \\/26\n1.4  Android源码结构 \\/32\n1.5  小结 \\/33\n第2章  Android的内核机制和结构剖析 \\/34\n2.1  Linux与Android的关系 \\/35\n2.1.1  为什么会选择Linux \\/35\n2.1.2  Android不是Linux \\/35\n2.2  Android对Linux内核的改动 \\/37\n2.2.1  Goldfish \\/37\n2.2.2  YAFFS2 \\/38\n2.2.3  蓝牙 \\/39\n2.2.4  调度器（Scheduler）\\/39\n2.2.5  Android新增的驱动 \\/40\n2.2.6  电源管理 \\/41\n2.2.7  杂项 \\/41\n2.3  Android对Linux内核的增强 \\/42\n2.3.1  Alarm（硬件时钟）\\/43\n2.3.2  Ashmem（匿名内存共享）\\/46\n2.3.3  Low Memory Killer（低内存管理）\\/52\n2.3.4  Logger（日志设备）\\/56\n2.3.5  Android PMEM \\/65\n2.3.6  switch \\/79\n2.3.7  Timed GPIO \\/88\n2.3.8  Android Ram Console \\/94\n2.4  小结 \\/99\n第3章  Android的IPC机制--Binder \\/100\n3.1  Binder概述 \\/101\n3.1.1  为什么选择Binder \\/101\n3.1.2  初识Binder \\/102\n3.2  Binder驱动的原理和实现 \\/102\n3.2.1  Binder驱动的原理 \\/102\n3.2.2  Binder驱动的实现 \\/103\n3.3  Binder的构架与实现 \\/132\n3.3.1  Binder的系统构架 \\/132\n3.3.2  Binder的机制和原理 \\/133\n3.4  小结 \\/150\n第4章  电源管理 \\/151\n4.1  电源管理概述 \\/152\n4.2  电源管理结构 \\/152\n4.3  Android的电源管理机制 \\/153\n4.4  Android电源管理机制的实现 \\/154\n4.5  小结 \\/187\n第5章  驱动的工作原理及实现机制 \\/188\n5.1  显示驱动（Framebuffer）\\/189\n5.1.1  Framebuffer的工作原理 \\/189\n5.1.2  Framebuffer的构架 \\/190\n5.1.3  Framebuffer驱动的实现机制 \\/190\n5.2  视频驱动（V4L和V4L2）\\/201\n5.2.1  V4L2介绍 \\/201\n5.2.2  V4L2的原理和构架 \\/201\n5.2.3  V4L2的实现 \\/202\n5.3  音频驱动（OSS和ALSA）\\/208\n5.3.1  OSS与ALSA介绍 \\/208\n5.3.2  OSS的构架与实现 \\/209\n5.3.3  ALSA的构架与实现 \\/213\n5.4  MTD驱动 \\/214\n5.4.1  MTD驱动的功能 \\/214\n5.4.2  MTD驱动的构架 \\/215\n5.4.3  MTD驱动的原理及实现 \\/215\n5.5  Event输入设备驱动 \\/223\n5.5.1  Input的系统构架 \\/223\n5.5.2  Event输入驱动的构架 \\/224\n5.5.3  Event输入驱动的原理 \\/224\n5.5.4  Event输入驱动的实现 \\/225\n5.6  蓝牙驱动（Bluetooth）\\/235\n5.6.1  Bluetooth驱动的构架 \\/235\n5.6.2  BlueZ的原理及实现 \\/237\n5.7  WLAN驱动（Wi-Fi）\\/244\n5.7.1  WLAN构架 \\/244\n5.7.2  Wi-Fi驱动的实现原理 \\/245\n5.8  小结 \\/245\n第6章  原生库的原理及实现 \\/246\n6.1  系统C库（Bionic Libc）\\/247\n6.1.1  Bionic Libc功能概述 \\/247\n6.1.2  Bionic Libc实现原理 \\/248\n6.2  功能库 \\/258\n6.2.1  WebKit构架与实现 \\/258\n6.2.2  多媒体框架与实现 \\/275\n6.2.3  Android SQLite框架及原理 \\/285\n6.3  扩展库 \\/289\n6.3.1  Skia底层库分析 \\/289\n6.3.2  OpenGL底层库分析 \\/299\n6.3.3  Android-OpenSSL实现及运用 \\/306\n6.3.4  FreeType及Font Engine Manager \\/317\n6.3.5  FreeType结构体系和渲染流程 \\/317\n6.4  原生服务 \\/328\n6.4.1  AudioFlinger实现 \\/328\n6.4.2  SurfaceFlinger实现 \\/341\n6.5  小结 \\/353\n第7章  硬件抽象层的原理与实现 \\/354\n7.1  硬件抽象层的实现原理 \\/355\n7.1.1  Android HAL构架 \\/355\n7.1.2  Android HAL的实现 \\/357\n7.2  Android Overlay构架与实现 \\/361\n7.2.1  Android Overlay系统构架 \\/361\n7.2.2  Overlay HAL框架与实现 \\/362\n7.2.3  Overlay与SurfaceFinger \\/369\n7.3  Android Camera 构架与实现 \\/375\n7.3.1  Android Camera系统构架 \\/375\n7.3.2  Camera HAL框架与实现 \\/377\n7.3.3  Camera本地实现 \\/385\n7.4  Android Audio HAL实现 \\/394\n7.4.1  Audio HAL框架 \\/395\n7.4.2  Android默认的Audio HAL实现 \\/398\n7.4.3  DUMP功能的Audio HAL实现 \\/400\n7.4.4  基于A2dp的蓝牙音频设备HAL实现 \\/402\n7.4.5  模拟器上的Audio HAL实现 \\/403\n7.5  Android RIL实现 \\/404\n7.5.1  Android RIL构架 \\/404\n7.5.2  radiooptiongs实现 \\/407\n7.5.3  libril库实现 \\/409\n7.5.4  reference-ril库实现 \\/415\n7.5.5  RILD守护进程实现 \\/418\n7.5.6  request流程分析 \\/423\n7.5.7  response流程分析 \\/427\n7.6  Android Sensor HAL实现 \\/434\n7.6.1  Android Sensor构建 \\/434\n7.6.2  Sensor HAL接口 \\/435\n7.6.3  Sensor HAL实现 \\/438\n7.7  Android WIFI HAL实现 \\/441\n7.7.1  Android WIFI系统构架 \\/441\n7.7.2  wpa_supplicant框架 \\/442\n7.7.3  WIFI HAL实现 \\/444\n7.8  Android蓝牙本地实现 \\/447\n7.8.1  Android蓝牙构架 \\/447\n7.8.2  BlueZ结构体系 \\/448\n7.8.3  BlueZ适配层 \\/452\n7.9  Android 定位实现 \\/453\n7.9.1  定位系统构架 \\/453\n7.9.2  GPS HAL实现 \\/454\n7.10  Android Power HAL实现 \\/459\n7.11  Android Vibrator HAL实现 \\/461\n7.12  小结 \\/462\n第8章  Dalvik虚拟机的构架、原理与实现 \\/463\n8.1  Dalvik虚拟机概述 \\/464\n8.1.1  什么是Dalvik虚拟机 \\/464\n8.1.2  Dalvik虚拟机的功能 \\/464\n8.1.3  Dalvik虚拟机与Java虚拟机的区别 \\/465\n8.2  Dalvik构架与实现 \\/466\n8.2.1  Dalvik系统构架 \\/466\n8.2.2  dx和dexdump工具 \\/468\n8.2.3  .dex文件格式解析 \\/470\n8.2.4  Dalvik内部机制 \\/487\n8.2.5  Dalvik进程管理 \\/492\n8.2.6  Dalvik内存管理 \\/501\n8.2.7  Dalvik加载器 \\/509\n8.2.8  Dalvik解释器 \\/517\n8.2.9  Dalvik JIT \\/519\n8.3  JNI的构架与实现 \\/523\n8.3.1  JNI构架 \\/523\n8.3.2  JNI实现 \\/524\n8.4  小结 \\/526\n第9章  Android 核心库 \\/527\n9.1  Android核心库简介 \\/528\n9.2  Android系统API \\/529\n9.2.1  android包 \\/529\n9.2.2  android资源包 \\/529\n9.2.3  ApiCheck机制 \\/529\n9.3  小结 \\/532\n后记 \\/533",
      "ebook_url": "http:\\/\\/read.douban.com\\/ebook\\/15161014\\/",
      "pages": "548",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s6379378.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s6379378.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s6379378.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/6047744\\/",
      "id": "6047744",
      "publisher": "机械工业出版社",
      "isbn10": "7111337271",
      "isbn13": "9787111337270",
      "title": "Android技术内幕",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/6047744",
      "alt_title": "",
      "author_intro": "杨丰盛，国内Android领域的先驱者和布道者，资深Android开发工程师，在Android应用开发方面有丰富的实战经验。他对Android的源代码进行了长达一年的系统学习和研究，对Android系统的架构设计和实现原理有非常深入的理解和认识，理论功底也十分深厚。国内著名IT技术网站51CTO推荐技术专家，曾多次接受《程序员》杂志采访并为其撰稿，同时他还多次应邀在国内的移动开发者大会和技术沙龙中开展讲座，深受欢迎。他还是畅销书作家，撰写的《Android应用开发揭秘》一书是目前Android领域口碑最好、销量也最好的一本书之一，这本书自上市以来已经重印9次，而且销量一直排在当当网、卓越网和互动网这3大网店的计算机类图书的排行榜前列。\n此外，他还精通Java、C、C++等语言，在机顶盒软件开发和MTK平台软件开发方面有非常丰富的经验。游戏开发也是他的专长，曾经参与过《三国群英传说》、《大航海传奇》、《养成计划》等游戏的开发，2007年荣获中国软件行业协会游戏软件分会(CGIA)认证及国际游戏开发教育联合会国际认证。",
      "summary": "《Android技术内幕：系统卷》是国内首本系统对Android的源代码进行深入分析的著作。全书将Android系统从构架上依次分为应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层等5个层次，旨在通过对Android系统源代码的全面分析来帮助开发者加深对Android系统架构设计和实现原理的认识，从而帮助他们解决开发中遇到的更加复杂的问题。\n全书分为两卷，系统卷主要分析了Linux内核层、硬件抽象层和系统运行库层的各个模块的底层原理和实现细节；应用卷主要分析了应用层和应用框架层的各个模块的底层原理和实现细节。\n具体而言，系统卷第1章首先从宏观上介绍了Android系统的架构以及各个层次之间的关系，然后介绍了如何获取Android源代码并搭建Android源代码开发环境和阅读环境的方法；第2章有针对性地剖析了Android的内核机制和结构，以及Android对Linux内核的改动和增强；第3章分析了Binder的架构和工作机制，以及Binder驱动的实现原理；第4章分析了Android电源管理模块的机制与实现；第5章全面地剖析了Android硬件设备驱动（显示、视频、音频、MTD、Event、蓝牙、WLAN等）的工作原理和实现，掌握这部分内容即可修改和编写基于Android的设备驱动程序；第6章深刻阐述了Android原生库的原理及实现，涉及系统C库、功能库、扩展库和原生的Server等重要内容；第7章系统地讲解了硬件抽象层的原理与实现，掌握这部分内容即可编写适合特定硬件设备驱动的抽象层接口；第8章和第9章是对系统运行库层的分析，主要讲解了Dalvik虚拟机的架构、原理与实现，以及Android的核心库相关的知识，掌握这部分内容即可完成对Android运行库的移植和修改。\n本书适合所有的高级Android应用开发工程师、Android系统开发工程师、Android移植工程师、Android系统架构师和所有对Android源码实现感兴趣的读者。",
      "ebook_price": "52.19",
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 81,
        "average": "7.1",
        "min": 0
      },
      "subtitle": "你的第一本Android书",
      "author": [
        "[美] Ed Burnette"
      ],
      "pubdate": "2009-11",
      "tags": [
        {
          "count": 154,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 51,
          "name": "手机开发",
          "title": "手机开发"
        },
        {
          "count": 22,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 19,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 12,
          "name": "入门",
          "title": "入门"
        },
        {
          "count": 7,
          "name": "programming",
          "title": "programming"
        },
        {
          "count": 6,
          "name": "IT",
          "title": "IT"
        },
        {
          "count": 5,
          "name": "Java",
          "title": "Java"
        }
      ],
      "origin_title": "Hello, Android : Introducing Google's Mobile Development Platform",
      "image": "https://img3.doubanio.com\\/mpic\\/s6089496.jpg",
      "binding": "平装",
      "translator": [
        "高朝勤",
        "杨越"
      ],
      "catalog": "第一部分　Android简介\n第1章　快速入门\n1.1　安装工具\n1.1.1　Java 5.0+\n1.1.2　Eclipse\n1.1.3　Android\n1.1.4　Eclipse插件\n1.2　创建第一个程序\n1.3　在模拟器上运行程序\n1.4　在手机上运行程序\n1.5　快速阅读指南\n第2章　基本概念\n2.1　Android的系统架构\n2.1.1　Linux内核\n2.1.2　本机库\n2.1.3　Android运行时\n2.1.4　应用程序框架\n2.1.5　应用程序\n2.2　它还活着\n2.2.1　进程不等于应用程序\n2.2.2　应用程序生命周期\n2.3　构建块\n2.3.1　活动\n2.3.2　意图\n2.3.3　服务\n2.3.4　内容提供者\n2.4　使用资源\n2.5　安全性\n2.6　快速阅读指南\n第二部分　Android基础知识\n第3章　设计用户界面\n3.1　数独游戏简介\n3.2　声明性设计\n3.3　创建启动界面\n3.4　使用替代资源\n3.5　实现About对话框\n3.6　应用主题\n3.7　添加菜单\n3.8　添加设置\n3.9　开始新游戏\n3.10　利用日志消息调试程序\n3.11　利用调试器调试程序\n3.12　退出游戏\n3.13　快速阅读指南\n第4章　绘制2D图形\n4.1　Android图形基础\n4.1.1　Color类\n4.1.2　Paint类\n4.1.3　Canvas类\n4.1.4　Path类\n4.1.5　Drawable类\n4.2　在Sudoku程序中添加图形\n4.2.1　开始游戏\n4.2.2　定义Game类\n4.2.3　定义PuzzleView类\n4.2.4　绘制游戏盘面\n4.2.5　绘制数字\n4.3　处理输入\n4.3.1　定义和更新选定区域\n4.3.2　输入数字\n4.3.3　增加提示\n4.3.4　抖动屏幕\n4.4　其他问题\n4.4.1　创建软键盘\n4.4.2　实现游戏逻辑\n4.4.3　其他功能\n4.5　更多改进\n4.6　快速阅读指南\n第5章　多媒体\n5.1　播放音频\n5.2　播放视频\n5.3　为数独游戏配上音乐\n5.4　快速阅读指南\n第6章　存储本地数据\n6.1　为数独游戏添加选项\n6.2　继续玩前一个游戏\n6.3　记住当前位置\n6.4　访问内部文件系统\n6.5　访问SD卡\n6.6　快速阅读指南\n第三部分　高级主题\n第7章　互联的世界\n7.1　通过意图实现浏览\n7.2　利用视图打开网页\n7.3　JavaScript与Java通信\n7.4　使用Web服务\n7.5　快速阅读指南\n第8章　定位与环境感知\n8.1　位置，位置，位置\n8.1.1　我在哪里\n8.1.2　更新位置\n8.1.3　模拟说明\n8.2　充分利用传感器\n8.2.1　了解传感器\n8.2.2　解析传感器的读数\n8.2.3　模拟说明\n8.3　地图功能\n8.3.1　嵌入MapView\n8.3.2　准备就绪\n8.3.3　模拟说明\n8.4　快速阅读指南\n第9章　SQL实战\n9.1　SQLite简介\n9.2　SQL基础\n9.2.1　DDL语句\n9.2.2　修改语句\n9.2.3　查询语句\n9.3　你好，数据库\n9.3.1　使用SQliteOpenHelper\n9.3.2　定义主程序\n9.3.3　添加一行\n9.3.4　运行一个查询\n9.3.5　显示查询结果\n9.4　数据绑定\n9.5　使用ContentProvider\n9.5.1　更改主程序\n9.5.2　添加一行\n9.5.3　运行一个查询\n9.6　实现ContentProvider\n9.7　快速阅读指南\n第10章　利用OpenGL实现3D图形\n10.1　理解3D图形\n10.2　OpenGL简介\n10.3　构建一个OpenGL程序\n10.4　管理线程\n10.5　构建一个模型\n10.6　光线、相机\n10.7　动作\n10.8　应用纹理\n10.9　透明效果\n10.10　快速阅读指南\n第四部分　附录\n附录A　Java与Android语言及其API\n附录B　参考书目",
      "pages": "196",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s6089496.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s6089496.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s6089496.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/4111350\\/",
      "id": "4111350",
      "publisher": "人民邮电出版社",
      "isbn10": "7115215367",
      "isbn13": "9787115215369",
      "title": "Android基础教程",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/4111350",
      "alt_title": "Hello, Android : Introducing Google's Mobile Development Platform",
      "author_intro": "Ed Burnette 资深软件技术专家，拥有20多年软件开发经验。SAS高级计算机实验室的联合创始人和高级研究员。他是www.planetandroid.com网站的创办人和ZDNet的专栏作家。除本书外，他还出版了Google Web Toolkit: Taking the Pain out of Ajax和 Eclipse IDE Pocket Guide等著作。",
      "summary": "《Android基础教程》内容完整丰富，具有较强的通用性，读者都能通过《Android基础教程》快速学习Android开发，提高相关技能。Android是谷歌公司开发的全新开源手机平台。《Android基础教程》是一部关于Android开发的基础教程，采用由浅入深、循序渐进的方式讨论Android。书中还结合数独游戏等实例更加形象生动地讲解了Android开发的基本流程，且每章最后都有一个“快速阅读指南”，更加方便了读者的阅读。",
      "price": "39.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 25,
        "average": "7.0",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[美] Vladimir Silva"
      ],
      "pubdate": "2011-2",
      "tags": [
        {
          "count": 104,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 53,
          "name": "游戏",
          "title": "游戏"
        },
        {
          "count": 29,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 18,
          "name": "游戏开发",
          "title": "游戏开发"
        },
        {
          "count": 11,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 7,
          "name": "android",
          "title": "android"
        },
        {
          "count": 7,
          "name": "CodingGame",
          "title": "CodingGame"
        },
        {
          "count": 7,
          "name": "NDK",
          "title": "NDK"
        }
      ],
      "origin_title": "Pro Android Games",
      "image": "https://img3.doubanio.com\\/mpic\\/s4592945.jpg",
      "binding": "平装",
      "translator": [
        "王恒",
        "苏金国 等"
      ],
      "catalog": "第1章 欢迎进入Android游戏世界        1\n1.1 必备技能        1\n1.1.1 扎实的Android基础        1\n1.1.2 Linux和Shell脚本的基本知识        3\n1.2 需要哪些软件工具        3\n1.3 建立环境        4\n1.3.1 获得Android源文件        4\n1.3.2 提取本地Android库        6\n1.3.3 为ARM处理器安装GNU工具链        8\n1.3.4 编写定制编译脚本        10\n1.4 建立开发环境        17\n1.5 已经成功迈出第一步        22\n第2章 在Android中编译本地代码        23\n2.1 第一个本地Android应用        23\n2.1.1 创建AVD        23\n2.1.2 创建Android项目        26\n2.1.3 应用体系结构        27\n2.2 编译和测试共享库        38\n2.2.1 缺少符号时的调试        40\n2.2.2 在设备上测试动态库        41\n2.2.3 用strace调试        42\n2.2.4 静态编译        43\n2.3 测试本地应用        44\n2.4 下一章内容        46\n第3章 从头构建Java游戏        47\n3.1 Android游戏与Java ME游戏        47\n3.2 创建你的第一个Java游戏——Space Blaster        48\n3.2.1 了解游戏的体系结构        49\n3.2.2 创建项目        50\n3.2.3 创建游戏的活动类        51\n3.2.4 创建游戏布局        53\n3.2.5 实现游戏        58\n3.2.6 处理按键和触控事件        66\n3.3 在模拟器上测试        69\n3.4 下一章内容        70\n第4章 Java游戏续篇：多边形的乐趣        71\n4.1 关于本章安排        71\n4.2 了解在Android中绘制多边形的问题        71\n4.3 了解绘制矩形的问题        73\n4.4 为Asteroids创建一个Polygon类        75\n4.5 为Asteroids创建PolygonSprite类        80\n4.6 游戏的体系结构        84\n4.7 创建项目        84\n4.7.1 创建游戏布局        85\n4.7.2 查看资源        86\n4.7.3 了解游戏生命期        87\n4.7.4 响应按键和触控事件        97\n4.8 在模拟器上测试Asteroids        100\n4.9 下一章内容        101\n第5章 OpenGL 3D图形与JNI混合        102\n5.1 移动设备的强大能力        103\n5.2 在Java中使用OpenGL        104\n5.2.1 Java主活动        106\n5.2.2 表面视图        108\n5.2.3 GL线程        110\n5.2.4 立方体渲染器        113\n5.2.5 Cube类        116\n5.3 以本地方式使用OpenGL        118\n5.3.1 主活动        120\n5.3.2 本地接口类        122\n5.3.3 对原示例的修改        123\n5.3.4 本地立方体渲染器        124\n5.3.5 本地立方体        131\n5.3.6 编译和运行示例        132\n5.4 OpenGL游戏移植到Android的问题        137\n5.5 大幕已经拉开        138\n第6章 3D射击游戏Ⅰ：面向Android的Wolfenstein 3D        139\n6.1 收集工具        139\n6.2 Wolf 3D        140\n6.3 游戏体系结构        143\n6.4 Wolf 3D的Java类        144\n6.4.1 创建主要的WolfLauncher类        145\n6.4.2 创建Wolf 3D主菜单        149\n6.4.3 处理按键和触控事件        150\n6.4.4 创建游戏循环        152\n6.4.5 建立本地回调        153\n6.4.6 创建声音和音乐处理器        155\n6.4.7 创建运动控制器处理程序        156\n6.4.8 创建运动控制器        158\n6.4.9 声音类        165\n6.4.10 本地接口类        174\n6.5 编写本地层        176\n6.5.1 初始化游戏循环        177\n6.5.2 用C到Java的回调级联传递消息        179\n6.6 编译本地库        185\n6.6.1 编写Makefile        186\n6.6.2 生成JNI头文件        187\n6.7 在模拟器中测试Wolf 3D        187\n6.8 下一章内容        189\n第7章 3D射击游戏Ⅱ：面向Android的Doom        191\n7.1 Java\\/C组合的无限潜能        191\n7.2 将Doom引入移动设备        192\n7.3 Doom的游戏体系结构        194\n7.4 Java主活动        195\n7.4.1 创建处理器        196\n7.4.2 游戏布局        197\n7.4.3 菜单和选择处理器        199\n7.4.4 按键和触控事件处理器        200\n7.4.5 本地回调处理器        202\n7.4.6 导航控件        205\n7.5 音频类        207\n7.6 本地接口类        208\n7.6.1 回调监听器        208\n7.6.2 本地方法        209\n7.6.3 C到Java的回调        209\n7.7 本地层        212\n7.7.1 本地方法实现        212\n7.7.2 对原游戏的修改        223\n7.8 Doom库（DSO）编译        229\n7.9 在模拟器中测试面向Android的Doom        230\n7.10 大功告成        232\n附录 部署与编译提示        234",
      "pages": "260",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s4592945.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s4592945.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s4592945.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/5908849\\/",
      "id": "5908849",
      "publisher": "人民邮电出版社",
      "isbn10": "711524698X",
      "isbn13": "9787115246981",
      "title": "精通Android游戏开发",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/5908849",
      "alt_title": "Pro Android Games",
      "author_intro": "Vladimir Silva 美国田纳西州立大学计算机科学硕士，美国国家荣誉协会成员。曾在IBM担任过4年研究工程师，在此期间积累了有关分布式和网格计算研究的丰富经验。为IBM发表过多篇计算机科学文章。除本书外，他还著有Grid Computing for Developers 和Practical Eclipse RCP Projects。",
      "summary": "作为引领移动技术潮流的软件平台，Android发布了NDK以支持Java和C的混合开发，使PC游戏可以在Android平台上焕发更多魅力。\n本书是为那些在Android游戏开发工作中寻求突破的人准备的。书中不仅通过Space Blaster和Asteroids这两个炫酷 的街机游戏深入介绍了如何从头构建纯Java游戏，更详细展示了如何将PC上的3D经典游戏Doom和Wolfenstein 3D移植到Android，阐释了在Java和C中混合使用OpenGL 3D图形和Java本地接口的技术。每个示例都提供了完全可用的实际源代码，方便读者理解复杂概念。作者语言简练，分析透彻，往往一语中的。在他的引导下，读者能很快学会将Java优雅的面向对象特性与C的强大功能集于一身，为Android平台构建任何类型的游戏。",
      "series": {
        "id": "660",
        "title": "图灵程序设计丛书"
      },
      "price": "45.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 91,
        "average": "6.8",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "余志龙",
        "陈昱勋",
        "郑名杰",
        "陈小凤",
        "郭秩均"
      ],
      "pubdate": "2009",
      "tags": [
        {
          "count": 110,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 24,
          "name": "Google",
          "title": "Google"
        },
        {
          "count": 20,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 19,
          "name": "应用开发",
          "title": "应用开发"
        },
        {
          "count": 15,
          "name": "移动平台",
          "title": "移动平台"
        },
        {
          "count": 13,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 13,
          "name": "软件开发",
          "title": "软件开发"
        },
        {
          "count": 13,
          "name": "sdk",
          "title": "sdk"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s3830632.jpg",
      "binding": "",
      "translator": [],
      "catalog": "",
      "pages": "616",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s3830632.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s3830632.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s3830632.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/3788013\\/",
      "id": "3788013",
      "publisher": "人民邮电出版社",
      "isbn10": "711520893X",
      "isbn13": "9787115208934",
      "title": "Google Android SDK开发范例大全",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/3788013",
      "alt_title": "",
      "author_intro": "",
      "summary": "本书以Android手机应用程序开发为主题，通过130多个范例全面且深度地整合了手机、网络及服务等多个开发领域，为读者提高程序设计功力提供了很大的帮助。.\n全书共分10章，主要以范例集的方式来讲述Android的知识点，详细介绍了开发Android的人机交互界面、Android常用的开发控件、使用 Android手机收发短信等通信服务、开发Android手机的自动服务功能和娱乐多媒体功能以及整合Android与Aoogle强大的网络服务等内容，随书光盘中包括了所有范例的程序代码。..\n本书讲述由浅入深，由Android的基础知识到实际开发应用，结构清晰、语言简洁，非常适合Android的初学者和Android的进阶程序开发者阅读参考。",
      "price": "79.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 36,
        "average": "7.1",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "纳德尔曼 (Greg Nudelman)"
      ],
      "pubdate": "2013-12-1",
      "tags": [
        {
          "count": 83,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 56,
          "name": "交互设计",
          "title": "交互设计"
        },
        {
          "count": 47,
          "name": "设计",
          "title": "设计"
        },
        {
          "count": 35,
          "name": "UI",
          "title": "UI"
        },
        {
          "count": 24,
          "name": "移动应用",
          "title": "移动应用"
        },
        {
          "count": 18,
          "name": "移动应用产品设计",
          "title": "移动应用产品设计"
        },
        {
          "count": 14,
          "name": "App",
          "title": "App"
        },
        {
          "count": 10,
          "name": "产品",
          "title": "产品"
        }
      ],
      "origin_title": "Android design patterns:interaction design solutions for developers",
      "image": "https://img1.doubanio.com\\/mpic\\/s27979208.jpg",
      "binding": "平装",
      "translator": [
        "袁国忠"
      ],
      "catalog": "第一部分　用户体验原则和Android特色\n第1章　向Android迁移（案例）　　2\n1.1 　启动图标　　2\n1.2 　操作栏与信息架构　　3\n1.2.1 　重新设计前　　3\n1.2.2 　重新设计后　　5\n1.3 　选项卡　　8\n1.4 　专用选择页　　8\n1.5 　选择控件　　9\n1.5.1 　重新设计前　　9\n1.5.2 　重新设计后　　10\n1.6 　按钮　　10\n1.7 　搜索结果屏幕　　11\n1.7.1 　重新设计前　　11\n1.7.2 　重新设计后　　12\n1.8 　结果详情屏幕　　13\n1.8.1 　重新设计前　　13\n1.8.2 　重新设计后　　14\n1.9 　最终结果　　16\n第2章　Android的特色　　19\n2.1 　这里是平面国　　19\n2.2 　轻按任何地方　　21\n2.3 　适合各种设备　　22\n2.4 　摆脱空间限制　　24\n2.5 　大局着眼，小处着手　　27\n第3章　Android分散化　　31\n3.1 　何谓分散化　　31\n3.2 　花无百日红　　31\n3.3 　Android设备类型　　32\n3.3.1 　紧凑型手机　　32\n3.3.2 　全尺寸移动手机　　33\n3.3.3 　平板手机　　34\n3.3.4 　小型平板　　35\n3.3.5 　大型平板　　37\n3.4 　为分散化而歌　　39\n第4章　移动设计流程　　40\n4.1 　现场观察用户如何与移动设备交互　　40\n4.2 　原型设计方法必须考虑尺寸因素　　40\n4.3 　用户测试必须涵盖运动、声音和多点触控等方面　　41\n4.4 　触控界面必须既简约又精巧　　41\n4.5 　愉悦不可或缺　　41\n4.6 　讲述完整的故事——为跨界而设计　　42\n4.7 　移动设计案例研究　　42\n4.7.1 　第1步：范围、概念和规划　　42\n4.7.2 　第2步：设计研讨会　　44\n4.7.3 　第3步：使用便利贴做RITE调查　　45\n4.7.4 　第4步：视觉设计　　48\n第二部分　Android 设计模式与反模式\n第5章　欢迎体验　　50\n5.1 　最终用户许可协议（反模式）　　50\n5.1.1 　出现的时间和场合　　50\n5.1.2  　示例　　50\n5.1.3  　为何要避免　　52\n5.1.4  　其他考虑因素　　52\n5.2 　联系障碍（反模式）　　52\n5.2.1 　出现的时间和场合　　52\n5.2.2 　示例　　53\n5.2.3 　为何要避免　　54\n5.2.4 　其他考虑因素　　54\n5.3 　注册（反模式）　　55\n5.3.1 　出现的时间和场合　　55\n5.3.2 　示例　　55\n5.3.3 　为何要避免　　56\n5.3.4 　其他考虑因素　　56\n5.4 　欢迎动画　　57\n5.4.1 　工作原理　　57\n5.4.2 　示例　　57\n5.4.3 　使用的时机和场合　　58\n5.4.4 　使用的原因　　58\n5.4.5 　其他用途　　58\n5.4.6 　Pet Shop应用　　58\n5.4.7 　平板应用　　59\n5.5 　使用说明　　59\n5.5.1 　工作原理　　59\n5.5.2 　示例　　59\n5.5.3 　使用的时机和场合　　61\n5.5.4 　使用的原因　　61\n5.5.5 　其他用途　　61\n5.5.6 　Pet Shop应用　　62\n5.5.7 　平板应用　　62\n第6章　主屏幕　　63\n6.1 　链接列表　　63\n6.1.1 　工作原理　　63\n6.1.2 　示例　　63\n6.1.3 　使用的时机和场合　　65\n6.1.4 　使用的原因　　65\n6.1.5 　其他用途　　65\n6.1.6 　Pet Shop应用　　66\n6.1.7 　平板应用　　66\n6.2 　仪表板　　66\n6.2.1 　工作原理　　67\n6.2.2 　示例　　67\n6.2.3 　使用的时机和场合　　67\n6.2.4 　使用的原因　　68\n6.2.5 　Pet Shop应用　　68\n6.2.6 　平板应用　　69\n6.3 　更新　　69\n6.3.1 　工作原理　　69\n6.3.2 　示例　　69\n6.3.3 　使用的时机和场合　　70\n6.3.4 　使用的原因　　70\n6.3.5 　其他用途　　71\n6.3.6 　Pet Shop应用　　71\n6.3.7 　平板应用　　72\n6.4 　浏览　　72\n6.4.1 　工作原理　　72\n6.4.2 　示例　　73\n6.4.3 　使用的时机和场合　　74\n6.4.4 　使用的原因　　74\n6.4.5 　其他用途　　74\n6.4.6 　Pet Shop应用　　75\n6.4.7 　平板应用　　76\n6.5 　地图　　76\n6.5.1 　工作原理　　76\n6.5.2 　示例　　76\n6.5.3 　使用的时机和场合　　77\n6.5.4 　使用的原因　　77\n6.5.5 　其他用途　　77\n6.5.6 　Pet Shop应用　　78\n6.5.7 　平板应用　　79\n6.6 　历史记录　　80\n6.6.1 　工作原理　　80\n6.6.2 　示例　　80\n6.6.3 　使用的时机和场合　　80\n6.6.4 　使用的原因　　81\n6.6.5 　其他用途　　81\n6.6.6 　Pet Shop应用　　82\n6.6.7 　平板应用　　83\n第7章　搜索　　84\n7.1 　语音搜索　　84\n7.1.1 　工作原理　　84\n7.1.2 　示例　　84\n7.1.3 　使用的时机和场合　　85\n7.1.4 　使用的原因　　86\n7.1.5 　其他用途　　86\n7.1.6 　Pet Shop应用　　87\n7.1.7 　平板应用　　87\n7.2 　自动完成与自动建议　　89\n7.2.1 　工作原理　　89\n7.2.2 　示例　　89\n7.2.3 　使用的时机和场合　　90\n7.2.4 　使用的原因　　90\n7.2.5 　其他用途　　91\n7.2.6 　Pet Shop应用　　91\n7.2.7 　平板应用　　92\n7.3 　轻按优先　　93\n7.3.1 　工作原理　　93\n7.3.2 　示例　　94\n7.3.3 　使用的时机和场合　　94\n7.3.4 　使用的原因　　94\n7.3.5 　其他用途　　95\n7.3.6 　Pet Shop应用　　95\n7.3.7 　平板应用　　95\n7.4 　拖动刷新　　96\n7.4.1 　工作原理　　96\n7.4.2 　示例　　96\n7.4.3 　使用的时机和场合　　97\n7.4.4 　使用的原因　　97\n7.4.5 　其他用途　　97\n7.4.6 　Pet Shop应用　　97\n7.4.7 　平板应用　　97\n7.5 　从菜单搜索　　98\n7.5.1 　工作原理　　98\n7.5.2 　示例　　98\n7.5.3 　使用的时机和场合　　99\n7.5.4 　使用的原因　　99\n7.5.5 　其他用途　　99\n7.5.6 　Pet Shop应用　　99\n7.5.7 　平板应用　　100\n7.6 　从操作栏搜索　　100\n7.6.1 　工作原理　　101\n7.6.2 　示例　　101\n7.6.3 　使用的时机和场合　　102\n7.6.4 　使用的原因　　102\n7.6.5 　其他用途　　102\n7.6.6 　Pet Shop应用　　103\n7.6.7 　平板应用　　103\n7.7 　专用搜索　　104\n7.7.1 　工作原理　　104\n7.7.2 　示例　　104\n7.7.3 　使用的时机和场合　　105\n7.7.4 　使用的原因　　105\n7.7.5 　其他用途　　105\n7.7.6 　Pet Shop应用　　105\n7.7.7 　平板应用　　106\n7.8 　在内容页面中搜索　　106\n7.8.1 　工作原理　　106\n7.8.2 　示例　　106\n7.8.3 　使用的时机和场合　　107\n7.8.4 　使用的原因　　107\n7.8.5 　其他用途　　107\n7.8.6 　Pet Shop应用　　108\n7.8.7 　平板应用　　108\n7.9 　搜索与细化分离（反模式）　　109\n7.9.1 　出现的时间和场合　　109\n7.9.2 　示例　　109\n7.9.3 　为何要避免　　110\n7.9.4 　其他考虑因素　　110\n第8章　排序和筛选　　112\n8.1 　残缺的细化（反模式）　　112\n8.1.1 　出现的时机和场合　　112\n8.1.2 　示例　　112\n8.1.3 　为何要避免　　114\n8.2 　细化页面　　115\n8.2.1 　工作原理　　115\n8.2.2 　示例　　115\n8.2.3 　使用的时机和场合　　118\n8.2.4 　使用的原因　　118\n8.2.5 　其他用途　　118\n8.2.6 　Pet Shop应用　　119\n8.2.7 　平板应用　　119\n8.3 　筛选带　　120\n8.3.1 　工作原理　　120\n8.3.2 　示例　　120\n8.3.3 　使用的时机和场合　　121\n8.3.4 　使用的原因　　121\n8.3.5 　其他用途　　121\n8.3.6 　Pet Shop应用　　122\n8.3.7 　平板应用　　123\n8.4 　并行架构　　123\n8.4.1 　工作原理　　124\n8.4.2 　示例　　124\n8.4.3 　使用的时机和场合　　125\n8.4.4 　使用的原因　　125\n8.4.5 　其他用途　　125\n8.4.6 　Pet Shop应用　　125\n8.4.7 　平板应用　　126\n8.5 　选项卡　　129\n8.5.1 　工作原理　　129\n8.5.2 　示例　　129\n8.5.3 　使用的时机和场合　　131\n8.5.4 　使用的原因　　131\n8.5.5 　其他用途　　131\n8.5.6 　Pet Shop应用　　132\n8.5.7 　平板应用　　133\n第9章　避免无结果或无关结果　　136\n9.1 　不指出系统状态（反模式）　　136\n9.1.1 　出现的时机和场合　　136\n9.1.2 　示例　　136\n9.1.3 　为何要避免　　137\n9.1.4 　其他考虑因素　　138\n9.2 　低效界面（反模式）　　138\n9.2.1 　出现的时机和场合　　138\n9.2.2 　示例　　138\n9.2.3 　其他考虑因素　　139\n9.3 　无用控件（反模式）　　139\n9.3.1 　出现的时机和场合　　139\n9.3.2 　示例　　139\n9.3.3 　为何要避免　　140\n9.4 　你要找的是不是……　　140\n9.4.1 　工作原理　　140\n9.4.2 　示例　　141\n9.4.3 　使用的时机和场合　　141\n9.4.4 　使用的原因　　142\n9.4.5 　其他用途　　142\n9.4.6 　Pet Shop应用　　142\n9.4.7 　平板应用　　142\n9.5 　部分匹配　　143\n9.5.1 　工作原理　　143\n9.5.2 　示例　　143\n9.5.3 　使用的时机和场合　　145\n9.5.4 　使用的原因　　145\n9.5.5 　其他用途　　145\n9.5.6 　Pet Shop应用　　145\n9.5.7 　平板应用　　145\n9.6 　本地结果　　146\n9.6.1 　工作原理　　146\n9.6.2 　示例　　146\n9.6.3 　使用的时机和场合　　147\n9.6.4 　使用的原因　　147\n9.6.5 　其他用途　　147\n9.6.6 　Pet Shop应用　　148\n9.6.7 　平板应用　　149\n第10章　数据输入　　150\n10.1 　滑块　　150\n10.1.1 　工作原理　　150\n10.1.2 　示例　　150\n10.1.3 　使用的时机和场合　　151\n10.1.4 　使用的原因　　151\n10.1.5 　其他用途　　152\n10.1.6 　Pet Shop应用　　152\n10.1.7 　平板应用　　153\n10.2 　步进器　　155\n10.2.1 　工作原理　　155\n10.2.2 　示例　　155\n10.2.3 　使用的时机和场合　　156\n10.2.4 　使用的原因　　156\n10.2.5 　其他用途　　156\n10.2.6 　Pet Shop应用　　157\n10.2.7 　平板应用　　159\n10.3 　可滚动的日历　　159\n10.3.1 　工作原理　　159\n10.3.2 　示例　　159\n10.3.3 　使用的时机和场合　　160\n10.3.4 　使用的原因　　160\n10.3.5 　其他用途　　160\n10.3.6 　Pet Shop应用　　161\n10.3.7 　平板应用　　161\n10.4 　日期与时间选择器　　163\n10.4.1 　工作原理　　163\n10.4.2 　示例　　163\n10.4.3 　使用的时机和场合　　166\n10.4.4 　使用的原因　　166\n10.4.5 　其他用途　　166\n10.4.6 　Pet Shop应用　　167\n10.4.7 　平板应用　　168\n10.5 　下拉列表　　170\n10.5.1 　工作原理　　170\n10.5.2 　示例　　170\n10.5.3 　使用的时机和场合　　172\n10.5.4 　使用的原因　　172\n10.5.5 　其他用途　　172\n10.5.6 　Pet Shop应用　　173\n10.5.7 　平板应用　　173\n10.6 　多选　　174\n10.6.1 　工作原理　　174\n10.6.2 　示例　　174\n10.6.3 　使用的时机和场合　　175\n10.6.4 　使用的原因　　175\n10.6.5 　其他用途　　175\n10.6.6 　Pet Shop应用　　176\n10.6.7 　平板应用　　177\n10.7 　自由文本输入与提取　　177\n10.7.1 　工作原理　　178\n10.7.2 　示例　　178\n10.7.3 　使用的时机和场合　　179\n10.7.4 　使用的原因　　179\n10.7.5 　其他用途　　179\n10.7.6 　Pet Shop应用　　179\n10.7.7 　平板应用　　179\n10.8 　带输入掩码的文本框　　182\n10.8.1 　工作原理　　183\n10.8.2 　示例　　183\n10.8.3 　使用的时机和场合　　185\n10.8.4 　使用的原因　　185\n10.8.5 　其他用途　　185\n10.8.6 　Pet Shop应用　　186\n10.8.7 　平板应用　　186\n10.9 　带原子实体的文本框　　189\n10.9.1 　工作原理　　189\n10.9.2 　示例　　189\n10.9.3 　使用的时机和场合　　189\n10.9.4 　使用的原因　　190\n10.9.5 　其他用途　　191\n10.9.6 　Pet Shop应用　　191\n10.9.7 　平板应用　　192\n第11章　表单　　193\n11.1 　内嵌式错误消息　　193\n11.1.1 　工作原理　　193\n11.1.2 　示例　　193\n11.1.3 　使用的时机和场合　　195\n11.1.4 　使用的原因　　195\n11.1.5 　其他用途　　195\n11.1.6 　Pet Shop应用　　196\n11.1.7 　平板应用　　197\n11.2 　提示框　　198\n11.2.1 　工作原理　　198\n11.2.2 　示例　　198\n11.2.3 　使用的时机和场合　　200\n11.2.4 　使用的原因　　200\n11.2.5 　其他用途　　200\n11.2.6 　Pet Shop应用　　201\n11.2.7 　平板应用　　201\n11.3 　弹出框　　203\n11.3.1 　工作原理　　203\n11.3.2 　示例　　203\n11.3.3 　使用的时机和场合　　205\n11.3.4 　使用的原因　　205\n11.3.5 　其他用途　　205\n11.3.6 　Pet Shop应用　　206\n11.3.7 　平板应用　　207\n11.4 　回调验证　　210\n11.4.1 　工作原理　　210\n11.4.2 　示例　　210\n11.4.3 　使用的时机和场合　　211\n11.4.4 　使用的原因　　211\n11.4.5 　其他用途　　211\n11.4.6 　Pet Shop应用　　211\n11.4.7 　平板应用　　212\n11.5 　取消\\/确定　　212\n11.5.1 　工作原理　　212\n11.5.2 　示例　　212\n11.5.3 　使用的时机和场合　　214\n11.5.4 　使用的原因　　215\n11.5.5 　其他用途　　215\n11.5.6 　Pet Shop应用　　217\n11.5.7 　平板应用　　217\n11.6 　上方标签　　221\n11.6.1 　工作原理　　221\n11.6.2 　示例　　221\n11.6.3 　使用的时机和场合　　222\n11.6.4 　使用的原因　　222\n11.6.5 　其他用途　　224\n11.6.6 　Pet Shop应用　　224\n11.6.7 　平板应用　　225\n11.7 　从环境获取输入　　227\n11.7.1 　工作原理　　227\n11.7.2 　示例　　227\n11.7.3 　使用的时机和场合　　231\n11.7.4 　使用的原因　　231\n11.7.5 　其他用途　　231\n11.7.6 　Pet Shop应用　　233\n11.7.7 　平板应用　　233\n11.8 　输入加速　　234\n11.8.1 　工作原理　　234\n11.8.2 　示例　　234\n11.8.3 　使用的时机和场合　　235\n11.8.4 　使用的原因　　235\n11.8.5 　其他用途　　235\n11.8.6 　Pet Shop应用　　235\n11.8.7 　平板应用　　236\n第12章　移动银行　　238\n12.1 　登录加速器　　238\n12.1.1 　工作原理　　238\n12.1.2 　示例　　238\n12.1.3 　使用的时机和场合　　241\n12.1.4 　使用的原因　　241\n12.1.5 　其他用途　　242\n12.1.6 　Pet Shop应用　　243\n12.1.7 　平板应用　　244\n12.2 　专用选择页面　　245\n12.2.1 　工作原理　　245\n12.2.2 　示例　　246\n12.2.3 　使用的时机和场合　　246\n12.2.4 　使用的原因　　246\n12.2.5 　其他用途　　247\n12.2.6 　Pet Shop应用　　247\n12.2.7 　平板应用　　248\n12.3 　表单至上　　249\n12.3.1 　工作原理　　249\n12.3.2 　示例　　249\n12.3.3 　使用的时机和场合　　250\n12.3.4 　使用的原因　　250\n12.3.5 　其他用途　　250\n12.3.6 　Pet Shop应用　　250\n12.3.7 　平板应用　　251\n12.4 　专用页面向导　　251\n12.4.1 　工作原理　　251\n12.4.2 　示例　　252\n12.4.3 　使用的时机和场合　　253\n12.4.4 　使用的原因　　253\n12.4.5 　其他用途　　253\n12.4.6 　Pet Shop应用　　254\n12.4.7 　平板应用　　255\n12.5 　以表单结尾的向导　　255\n12.5.1 　工作原理　　255\n12.5.2 　示例　　255\n12.5.3 　使用的时机和场合　　256\n12.5.4 　使用的原因　　256\n12.5.5 　其他用途　　257\n12.5.6 　Pet Shop应用　　257\n12.5.7 　平板应用　　258\n12.6 　核对?确认　　260\n12.6.1 　工作原理　　260\n12.6.2 　示例　　260\n12.6.3 　使用的时机和场合　　261\n12.6.4 　使用的原因　　261\n12.6.5 　其他用途　　261\n12.6.6 　Pet Shop应用　　262\n12.6.7 　平板应用　　262\n12.7 　近场通信　　263\n12.7.1 　工作原理　　263\n12.7.2 　示例　　263\n12.7.3 　使用的时机和场合　　266\n12.7.4 　使用的原因　　266\n12.7.5 　其他用途　　267\n12.7.6 　Pet Shop应用　　267\n12.7.7 　平板应用　　268\n第13章　导航　　270\n13.1 　上窜下跳（反模式）　　270\n13.1.1 　出现的时间和场合　　270\n13.1.2 　示例　　270\n13.1.3 　为何要避免　　271\n13.1.4 　其他考虑因素　　271\n13.1.5 　出现的时间和场合　　271\n13.2 　多个推荐区域（反模式）　　272\n13.2.1 　出现的时间和场合　　272\n13.2.2 　示例　　272\n13.2.3 　为何要避免　　273\n13.2.4 　其他考虑因素　　273\n13.3 　轮播　　274\n13.3.1 　工作原理　　274\n13.3.2 　示例　　274\n13.3.3 　使用的时机和场合　　275\n13.3.4 　使用的原因　　275\n13.3.5 　其他用途　　275\n13.3.6 　Pet Shop应用　　276\n13.3.7 　平板应用　　276\n13.4 　弹出式菜单　　279\n13.4.1 　工作原理　　279\n13.4.2 　示例　　279\n13.4.3 　使用的时机和场合　　281\n13.4.4 　使用的原因　　281\n13.4.5 　其他用途　　281\n13.4.6 　Pet Shop应用　　282\n13.4.7 　平板应用　　283\n13.5 　水印　　285\n13.5.1 　工作原理　　285\n13.5.2 　示例　　286\n13.5.3 　使用的时机和场合　　287\n13.5.4 　使用的原因　　287\n13.5.5 　其他用途　　287\n13.5.6 　Pet Shop应用　　287\n13.5.7 　平板应用　　288\n13.6 　瑞士军刀导航　　290\n13.6.1 　工作原理　　290\n13.6.2 　示例　　290\n13.6.3 　使用的时机和场合　　293\n13.6.4 　使用的原因　　293\n13.6.5 　其他用途　　294\n13.6.6 　Pet Shop应用　　297\n13.6.7 　平板应用　　298\n13.7 　集成　　299\n13.7.1 　工作原理　　300\n13.7.2 　示例　　300\n13.7.3 　使用的时机和场合　　300\n13.7.4 　使用的原因　　301\n13.7.5 　其他用途　　301\n13.7.6 　Pet Shop应用　　303\n13.7.7 　平板应用　　303\n第14章　平板模式　　306\n14.1 　片段　　306\n14.1.1 　工作原理　　306\n14.1.2 　示例　　306\n14.1.3 　使用的时机和场合　　307\n14.1.4 　使用的原因　　308\n14.1.5 　其他用途　　308\n14.2 　复合视图　　308\n14.2.1 　工作原理　　308\n14.2.2 　示例　　308\n14.2.3 　使用的时机和场合　　309\n14.2.4 　使用的原因　　309\n14.2.5 　其他用途　　309\n14.3 　侧面导航（试验模式）　　310\n14.3.1 　工作原理　　310\n14.3.2 　示例　　311\n14.3.3 　使用的时机和场合　　312\n14.3.4 　使用的原因　　313\n14.3.5 　其他用途　　313\n14.4 　将内容用作导航元素　　314\n14.4.1 　工作原理　　314\n14.4.2 　示例　　314\n14.4.3 　使用的时机和场合　　316\n14.4.4 　使用的原因　　316\n14.4.5 　其他用途　　316\n14.5 　二维更多类似　　317\n14.5.1 　工作原理　　317\n14.5.2 　示例　　317\n14.5.3 　使用的时机和场合　　318\n14.5.4 　使用的原因　　318\n14.5.5 　其他用途　　318\n14.6 　C形轻扫（试验模式）　　319\n14.6.1 　工作原理　　320\n14.6.2 　示例　　320\n14.6.3 　使用的时机和场合　　321\n14.6.4 　使用的原因　　321\n14.6.5 　其他用途　　321",
      "pages": "321",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s27979208.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s27979208.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s27979208.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/25764505\\/",
      "id": "25764505",
      "publisher": "人民邮电出版社",
      "isbn10": "7115334684",
      "isbn13": "9787115334688",
      "title": "Android应用UI设计模式",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/25764505",
      "alt_title": "Android design patterns:interaction design solutions for developers",
      "author_intro": "Greg Nudelman 是DesignCaffeine公司CEO兼移动体验策略师，具有15年的移动体验从业经验，曾为eBay、WebEx、Wells Fargo、PayPal、Safeway、Cisco、IBM、The Associated Press和Groupo n等财富500强企业，以及非盈利性组织和创业公司实现跨平台的数字体验，受到数百万客户的好评。Greg还是很多著名用户体验设计图书的作者，其中包括Designing Search: UX Strategies for eCommerce Success。",
      "summary": "目前，谷歌Android 操作系统在移动市场中风头正劲，并且未来发展势不可挡。本书面向Android 4.0+操作系统，是市面上第一本深入解析Android 界面设计的佳作。本书从适用于移动设备和平板的通用模式以及Android UI 设计指南出发，深入探讨了58 种重要的Android 交互设计模式及其应用。每种模式登场之前，先用基本知识铺路，接着展示常见的设计陷阱和欠佳的设计模式，最后对这些模式进行改进，从而打造卓越的交互设计以及直观的信息架构。\n本书可满足移动设计人员和开发人员的需求，帮助他们轻松成为移动用户体验设计高手。",
      "price": "69.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 82,
        "average": "6.7",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "韩超",
        "梁泉"
      ],
      "pubdate": "2010-1",
      "tags": [
        {
          "count": 85,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 19,
          "name": "手机开发",
          "title": "手机开发"
        },
        {
          "count": 19,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 12,
          "name": "框架原理",
          "title": "框架原理"
        },
        {
          "count": 11,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 8,
          "name": "技术",
          "title": "技术"
        },
        {
          "count": 6,
          "name": "程序设计",
          "title": "程序设计"
        },
        {
          "count": 5,
          "name": "Linux",
          "title": "Linux"
        }
      ],
      "origin_title": "",
      "image": "https://img3.doubanio.com\\/mpic\\/s6111260.jpg",
      "binding": "",
      "translator": [],
      "catalog": "第1章  Android系统概述第2章  Android系统开发综述第3章  Android的Linux内核与驱动程序第4章  Android的底层库和程序第5章  Android的Java虚拟机和Java环境第6章  Android的GUI系统第7章  Android的Audio系统第8章  Android的Video输入输出系统第9章  Android的多媒体系统第10章  Android的电话部分第11章  Android的连接部分第12章  Android的传感器系统第13章  Android应用程序概述及框架第14章  Android应用程序的主要方面第15章  Android应用程序的设计思想",
      "pages": "393",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s6111260.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s6111260.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s6111260.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/4251755\\/",
      "id": "4251755",
      "publisher": "电子工业出版社",
      "isbn10": "7121101386",
      "isbn13": "9787121101380",
      "title": "Android系统原理及开发要点详解",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/4251755",
      "alt_title": "",
      "author_intro": "韩超，工学硕士，毕业于北京交通大学电子学院。在AKAE期间，担任ARM-Linux嵌入式系统平台的开发和教学工作，重视完整的知识体系与工程技术相结合。",
      "summary": "《Android系统原理及开发要点详解》全面介绍开放的移动电话平台Android系统，包括Android系统中的Linux驱动、本地框架、Java框架和Java应用4个层次。《Android系统原理及开发要点详解》内容以知识性内容为纲，重点关注开发要点，各个部分内容注重相互照应，按照清晰的思路向读者介绍整个Android系统的原理和开发方法。\n《Android系统原理及开发要点详解》按照Android系统的框架和各个子系统的主线，重点介绍开发Android应用程序和构建硬件抽象层。其内容涵盖了Android应用程序开发和Android系统移植构建手机系统两大方面。\n《Android系统原理及开发要点详解》既适合从事Android各个层次开发的工程师阅读，也适合通用嵌入式Linux系统的学习者使用。",
      "price": "58.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 50,
        "average": "8.2",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[法] Hervé Guihot"
      ],
      "pubdate": "2012-10",
      "tags": [
        {
          "count": 122,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 52,
          "name": "性能",
          "title": "性能"
        },
        {
          "count": 19,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 13,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 13,
          "name": "软件开发",
          "title": "软件开发"
        },
        {
          "count": 11,
          "name": "android",
          "title": "android"
        },
        {
          "count": 8,
          "name": "程序设计",
          "title": "程序设计"
        },
        {
          "count": 7,
          "name": "软件工程",
          "title": "软件工程"
        }
      ],
      "origin_title": "Pro Android Apps Performance Optimization",
      "image": "https://img3.doubanio.com\\/mpic\\/s22718876.jpg",
      "binding": "平装",
      "translator": [
        "白龙"
      ],
      "catalog": "目 　 　录\n第1章 　Java代码优化　　1\n1.1 　Android如何执行代码　　1\n1.2 　优化斐波纳契数列　　4\n1.2.1 　从递归到迭代　　4\n1.2.2 　BigInteger　　6\n1.3 　缓存结果　　10\n1.4 　API等级　　12\n1.5 　数据结构　　14\n1.6 　响应能力　　17\n1.6.1 　推迟初始化　　19\n1.6.2 　StrictMode　　19\n1.7 　SQLite　　21\n1.7.1 　SQLite语句　　21\n1.7.2 　事务　　25\n1.7.3 　查询　　26\n1.8 　总结　　27\n第2章 　NDK入门　　28\n2.1 　NDK里有什么　　28\n2.2 　混合使用Java和C\\/C++代码　　31\n2.2.1 　声明本地方法　　31\n2.2.2 　实现JNI粘合层　　32\n2.2.3 　创建Makefile　　33\n2.2.4 　实现本地函数　　35\n2.2.5 　编译本地库　　36\n2.2.6 　加载本地库　　37\n2.3 　Application.mk　　37\n2.3.1 　为（几乎）所有设备优化　　39\n2.3.2 　支持所有设备　　40\n2.4 　Android.mk　　43\n2.5 　使用C\\/C++改进性能　　45\n2.6 　本地Acitivity　　52\n2.6.1 　构建缺失的库　　54\n2.6.2 　替代方案　　59\n2.7 　总结　　60\n第3章 　NDK进阶　　61\n3.1 　汇编　　61\n3.1.1 　最大公约数　　62\n3.1.2 　色彩转换　　66\n3.1.3 　并行计算平均值　　70\n3.1.4 　ARM指令　　74\n3.1.5 　ARM NEON　　79\n3.1.6 　CPU特性　　80\n3.2 　C扩展　　81\n3.2.1 　内置函数　　82\n3.2.2 　向量指令　　82\n3.3 　技巧　　86\n3.3.1 　内联函数　　87\n3.3.2 　循环展开　　87\n3.3.3 　内存预读取　　87\n3.3.4 　用LDM\\/STM替换LDR\\/STD　　89\n3.4 　总结　　89\n第4章 　高效使用内存　　90\n4.1 　说说内存　　90\n4.2 　数据类型　　91\n4.2.1 　值的比较　　93\n4.2.2 　其他算法　　95\n4.2.3 　数组排序　　96\n4.2.4 　定义自己的类　　97\n4.3 　访问内存　　98\n4.4 　排布数据　　100\n4.5 　垃圾收集　　104\n4.5.1 　内存泄漏　　105\n4.5.2 　引用　　106\n4.6 　API　　109\n4.7 　内存少的时候　　110\n4.8 　总结　　111\n第5章 　多线程和同步　　112\n5.1 　线程　　112\n5.2 　AsyncTask　　115\n5.3 　Handler和Looper　　118\n5.3.1 　Handler　　118\n5.3.2 　Looper　　120\n5.4 　数据类型　　120\n5.5 　并发　　124\n5.6 　多核　　125\n5.6.1 　为多核修改算法　　126\n5.6.2 　使用并发缓存　　129\n5.7 　Activity生命周期　　131\n5.7.1 　传递信息　　132\n5.7.2 　记住状态　　134\n5.8 　总结　　137\n第6章 　性能评测和剖析　　138\n6.1 　时间测量　　138\n6.1.1 　System.nanoTime()　　139\n6.1.2 　Debug.threadCpuTimeNanos()　　140\n6.2 　方法调用跟踪　　141\n6.2.1 　Debug.startMethodTracing()　　141\n6.2.2 　使用Traceview工具　　142\n6.2.3 　DDMS中的Traceview　　144\n6.2.4 　本地方法跟踪　　145\n6.3 　日志　　147\n6.4 　总结　　148\n第7章 　延长电池续航时间　　150\n7.1 　电池　　150\n7.2 　禁用广播接收器　　155\n7.3 　网络　　159\n7.3.1 　后台数据　　159\n7.3.2 　数据传输　　160\n7.4 　位置　　162\n7.4.1 　注销监听器　　163\n7.4.2 　更新频率　　164\n7.4.3 　多种位置服务　　164\n7.4.4 　筛选定位服务　　166\n7.4.5 　最后已知位置　　168\n7.5 　传感器　　169\n7.6 　图形　　170\n7.7 　提醒　　171\n7.8 　WakeLock　　173\n7.9 　总结　　175\n第8章 　图形　　176\n8.1 　布局优化　　176\n8.1.1 　相对布局　　178\n8.1.2 　合并布局　　181\n8.1.3 　重用布局　　183\n8.1.4 　ViewStub　　184\n8.2 　布局工具　　185\n8.2.1 　层级视图　　186\n8.2.2 　layoutopt　　186\n8.3 　OpenGL ES　　186\n8.3.1 　扩展　　187\n8.3.2 　纹理压缩　　189\n8.3.3 　Mipmap　　193\n8.3.4 　多APK　　194\n8.3.5 　着色　　195\n8.3.6 　场景复杂性　　195\n8.3.7 　消隐　　195\n8.3.8 　渲染模式　　195\n8.3.9 　功耗管理　　195\n8.4 　总结　　196\n第9章 　RenderScript　　197\n9.1 　概览　　197\n9.2 　Hello World　　199\n9.3 　Hello Rendering　　202\n9.3.1 　创建渲染脚本　　202\n9.3.2 　创建RenderScriptGL Context　　203\n9.3.3 　展开RSSurfaceView　　204\n9.3.4 　设置内容视图　　204\n9.4 　在脚本中添加变量　　205\n9.5 　HelloCompute　　208\n9.5.1 　Allocation　　209\n9.5.2 　rsForEach　　210\n9.5.3 　性能　　213\n9.6 　自带的RenderScript API　　214\n9.6.1 　rs_types.rsh　　215\n9.6.2 　rs_core.rsh　　217\n9.6.3 　rs_cl.rsh　　219\n9.6.4 　rs_math.rsh　　222\n9.6.5 　rs_graphics.rsh　　223\n9.6.6 　rs_time.rsh　　224\n9.6.7 　rs_atomic.rsh　　225\n9.7 　RenderScript与NDK对比　　225\n9.8 　总结　　226\n",
      "pages": "226",
      "images": {
        "small": "https://img3.doubanio.com\\/spic\\/s22718876.jpg",
        "large": "https://img3.doubanio.com\\/lpic\\/s22718876.jpg",
        "medium": "https://img3.doubanio.com\\/mpic\\/s22718876.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/19976838\\/",
      "id": "19976838",
      "publisher": "人民邮电出版社",
      "isbn10": "7115272417",
      "isbn13": "9787115272416",
      "title": "Android应用性能优化",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/19976838",
      "alt_title": "Pro Android Apps Performance Optimization",
      "author_intro": "作者介绍：\nHervé Guihot 目前在联发科技公司（MTK, www.mediatek.com）担任软件工程经理。他有十多年的嵌入式系统开发工作经验，主要与数字电视技术相关。目前正在研究如何将Android引入基于ARM的数字家庭平台（电视，蓝光播放器）。",
      "summary": "内容简介：\n今天的Android应用开发者经常要想尽办法来提升程序性能。由于应用越来越复杂，这个问题也变得越来越棘手。本书主要介绍如何快速高效地优化应用，让应用变得稳定高效。你将学会利用Android SDK和NDK来混合或单独使用Java、C\\/C++来开发应用。书中还特别讲解了如下内容：\n•        一些OpenGL的优化技术以及RenderScript（Android的新特性）的基础知识；\n•        利用SDK来优化应用的Java代码的技巧；\n•        通过高效使用内存来提升性能的技巧；\n•        延长电池使用时间的技巧；\n•        使用多线程的时机及技巧；\n•        评测剖析代码的技巧。\n把本书的内容学以致用，你的编程技术就会得到关键性的提升，写出的应用就会更为健壮高效，从而广受用户好评，并最终获得成功。",
      "price": "49.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 53,
        "average": "7.0",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "[美]Jonathan Stark"
      ],
      "pubdate": "2011-6",
      "tags": [
        {
          "count": 89,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 48,
          "name": "JavaScript",
          "title": "JavaScript"
        },
        {
          "count": 38,
          "name": "CSS",
          "title": "CSS"
        },
        {
          "count": 37,
          "name": "HTML",
          "title": "HTML"
        },
        {
          "count": 36,
          "name": "移动互联网开发",
          "title": "移动互联网开发"
        },
        {
          "count": 25,
          "name": "html5",
          "title": "html5"
        },
        {
          "count": 20,
          "name": "开发",
          "title": "开发"
        },
        {
          "count": 17,
          "name": "交互设计",
          "title": "交互设计"
        }
      ],
      "origin_title": "Building Android Apps with HTML, CSS, and JavaScript",
      "image": "https://img1.doubanio.com\\/mpic\\/s6537454.jpg",
      "binding": "",
      "translator": [
        "申林",
        "邹宇"
      ],
      "catalog": "第1章 入门指南\t1\n网络应用程序与原生应用程序的对比\t1\n什么是网络应用程序\t1\n什么是原生应用程序\t1\n优势和劣势\t2\n哪种方法最合适你\t2\n网络编程速成\t3\nhtml入门\t3\ncss入门\t5\njavascript入门\t9\n第2章 基本样式\t13\n还没网站\t13\n准备工作\t14\n准备独立的android样式表\t17\n控制页面缩放\t18\n添加android css\t20\n添加android视觉效果\t23\n使用jquery添加基本行为\t24\n内容回顾\t30\n.第3章 高级样式\t31\n添加一点ajax\t31\n交通警察\t31\n添加一些内容\t34\njavascript的路由请求\t34\n简单的点缀\t36\n进度指示器（process indicator）\t36\n设置页面标题\t39\n处理长标题\t41\n自动回到顶部\t42\n只拦截本地链接\t43\n编写自己的返回按钮\t44\n在主屏幕上添加图标\t50\n内容回顾\t50\n第4章 动画\t51\n来自朋友的帮助\t51\n让主页滑动起来\t51\n添加dates面板\t54\n添加date面板\t56\n添加new entry面板\t57\n添加settings面板\t60\n将所有代码放在一起\t61\n自定义jqtouch\t64\n内容回顾\t65\n第5章 客户端数据存储\t67\nweb storage\t67\n将用户设置保存到本地\t68\n将选中的数据保存到session storage中\t71\nweb sql database\t74\n创建数据库\t74\n插入行\t77\n检索行及处理结果集\t80\n删除行\t84\n内容回顾\t88\nweb database错误编码参考\t88\n第6章 走向离线\t89\n离线应用程序缓存基础\t89\n在线whitelist（白名单）和fallback（备选）选项\t92\n创建动态manifest文件\t95\n调试\t101\njavascript控制台（javascript console）\t101\n内容回顾\t104\n第7章 走向原生\t105\nphonegap简介\t105\n下载android sdk\t107\n下载phonegap\t110\n配置环境\t111\n创建android virtual device（android虚拟设备）\t113\n创建kilogap\t114\n在模拟器中安装kilogap\t118\n使用屏幕的全部高度\t121\n自定义程序图标\t122\n在手机上安装kilogap\t123\n使用javascript来控制手机\t123\nbeep（蜂鸣）、vibrate（振动）及alert（提醒）\t123\n地理位置\t127\n加速度传感器\t133\n内容回顾\t136\n第8章 将应用程序提交到android应用程序市场上\t137\n准备程序的发行版本\t137\n移除调试代码\t137\n应用程序版本管理\t138\n应用程序签名管理\t138\n将程序上传到android应用程序市场\t141\n直接分发程序\t143\n延伸阅读\t145\n附录 147\n索引\t151",
      "pages": "165",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s6537454.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s6537454.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s6537454.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/6512489\\/",
      "id": "6512489",
      "publisher": "电子工业出版社",
      "isbn10": "7121132370",
      "isbn13": "9787121132377",
      "title": "使用HTML、CSS和JavaScript开发Android程序",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/6512489",
      "alt_title": "Building Android Apps with HTML, CSS, and JavaScript",
      "author_intro": "JonathancStark是一位移动应用程序开发顾问及研究如何将桌面数据发布到Web方面的专家.a他同时是3本关于Web应用程序编程书籍的作者.a",
      "summary": "《使用html、css和javascript开发android程序 》是《building android apps with html, css, and javascript》的中文翻译版，主要介绍了如何使用现有的web技术构建android应用程序。\n《使用html、css和javascript开发android程序 》的前3章介绍了如何使用基本的html、css和javascript技术构建简单的网络程序；第4章介绍了使用jqtouch技术使得网络程序与原生程序的体验相同；第5、6两章则讲述了利用html5的客户端存储技术使网络程序实现本地存储，进而成为一个离线应用；第7章利用phonegap项目使网络程序也可以操作android硬件特性；第8章则为开发者描绘了在android应用程序市场上发布应用程序的流程和一些技巧。\n《使用html、css和javascript开发android程序 》最大的特点是深入浅出，每一部分都与实例结合，增强了可操作性，更通俗易懂。无论对于希望通过web技术构建移动应用的初学者，还是对于希望进入android领域的web工程师，都是一本不错的参考书。",
      "price": "39.00元"
    },
    {
      "rating": {
        "max": 10,
        "numRaters": 49,
        "average": "8.0",
        "min": 0
      },
      "subtitle": "",
      "author": [
        "马尔科·加尔根塔"
      ],
      "pubdate": "2012-7",
      "tags": [
        {
          "count": 99,
          "name": "Android",
          "title": "Android"
        },
        {
          "count": 18,
          "name": "编程",
          "title": "编程"
        },
        {
          "count": 14,
          "name": "O'Reilly",
          "title": "O'Reilly"
        },
        {
          "count": 13,
          "name": "计算机",
          "title": "计算机"
        },
        {
          "count": 4,
          "name": "android",
          "title": "android"
        },
        {
          "count": 4,
          "name": "programming",
          "title": "programming"
        },
        {
          "count": 3,
          "name": "计算机技术",
          "title": "计算机技术"
        },
        {
          "count": 3,
          "name": "IT",
          "title": "IT"
        }
      ],
      "origin_title": "",
      "image": "https://img1.doubanio.com\\/mpic\\/s11328538.jpg",
      "binding": "",
      "translator": [
        "李亚舟",
        "任中龙",
        "杜钢"
      ],
      "catalog": "",
      "pages": "261",
      "images": {
        "small": "https://img1.doubanio.com\\/spic\\/s11328538.jpg",
        "large": "https://img1.doubanio.com\\/lpic\\/s11328538.jpg",
        "medium": "https://img1.doubanio.com\\/mpic\\/s11328538.jpg"
      },
      "alt": "http:\\/\\/book.douban.com\\/subject\\/11501595\\/",
      "id": "11501595",
      "publisher": "电子工业出版社",
      "isbn10": "7121172631",
      "isbn13": "9787121172632",
      "title": "Learning Android（中文版）",
      "url": "http:\\/\\/api.douban.com\\/v2\\/book\\/11501595",
      "alt_title": "",
      "author_intro": "",
      "summary": "《Learning Android(中文版)》为Android开发入门图书，循序渐进地介绍了如何利用Android基本构件来实现构造用户界面、存储数据、连接网络等实践中必不可少的需求。《Learning Android(中文版)》以亲手实现一个类Twitter的应用为主线，通过不断为其添加功能展开讲解。而这一学习过程积累出的代码模式库，可以灵活运用于真实Android应用开发。《Learning Android(中文版)》内容包括但不限于：Android平台概览、Android设计架构、Android开发环境配置、基本Android的用户界面构建、UI元件组织方法、构建执行后台任务与更新数据的服务、AIDL与NDK介绍等。",
      "price": "49.00元"
    }
  ]
}